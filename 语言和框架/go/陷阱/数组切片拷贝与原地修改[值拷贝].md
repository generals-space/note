
数组与切片是不同的东西

## 数组

1. 数组无法使用 append() 添加元素, 就算该数组不是满的也不行, 编译期就会报错.
    - `array := [...]int{1, 2, 3}`此语句声明的是一个数组而非切片, 编译器会将其翻译成`[3]int`数组.
    - `var array [...]int = [...]int{1, 2, 3}`这种是错误的
    - `var array [3]int   = [...]int{1, 2, 3}`这种倒是可以
2. 不是满的数组, 空闲成员会填上默认值.

## 切片

1. `slice := make([]int, 3, 5)`创建的切片, 虽然cap为5, 但是不能通过`slice[4]`直接对后面的空位成员赋值, 会出现`index out of range`越界错误.

我们知道, 切片类型在`append()`的时候, 如果超过了`cap`容量, 会进行全量拷贝, 那时就不再是原切片了. 而在发生全量拷贝之前, 新切片与原切片(或原数组)是会相互影响的.

```go
	// 数组剩余的2个空位会补上0
	var array [5]int = [5]int{1, 2, 3}
	log.Printf("%+v", array) // [1 2 3 0 0]

	// 原数组的成员变动会影响切片
	slice := array[:]
	array[4] = 5
	log.Printf("%+v", slice) // [1 2 3 0 5]
	
	// 切片的成员变动也会影响原数组
	slice[3] = 4
	log.Printf("%+v", array) // [1 2 3 4 5]
```

再来看看发生全量拷贝后.

```go
	var s1 []int = make([]int, 3, 4)
	log.Printf("%+v", s1) // [0 0 0]

	s2 := s1[:]
	// 此时还没有扩容, 但是 s2 没有跟上 s1 的变动,
	// 应该是因为, **s2 此时的 cap 为 3, 而不是 s2 的 4**.
	s1 = append(s1, 4)
	log.Printf("%+v", s1) // [0 0 0 4]
	log.Printf("%+v", s2) // [0 0 0]
	// 但是 s1 在范围在 3 以内的成员变动, 仍然可以影响到 s2,
	// 说明 s1 的地址还没有发生变动.
	s1[0] = 1
	log.Printf("%+v", s2) // [1 0 0]

	// 接下来的 append 后, s1 的底层地址就变了
	s1 = append(s1, 5)
	log.Printf("%+v", s1) // [1 0 0 4 5]
	log.Printf("%+v", s2) // [1 0 0]
	// 此时 s1 在范围在 3 以内的成员变动, 就无法再影响 s2 了.
	s1[1] = 2
	log.Printf("%+v", s1) // [1 2 0 4 5]
	log.Printf("%+v", s2) // [1 0 0]
```

本来 append() 扩容后, 旧切片会被回收, 不过, 这里被其他切片引用再扩容, 旧切片就没法被回收了.
