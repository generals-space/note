# golang-逃逸分析

逃逸, 应该是单指按照传统的思维应该将空间分配到栈上, 但实际分配在了堆上.

1. 函数内局部变量会分配在栈上, 但较大变量会直接分配到堆上;
2. 通过函数参数传递的指针所指向的对象会分配在堆上, 但有一种例外, 返回指针的函数的主调函数并没有用变量存储这个指针(比如 `_ = callee()`).

