# golang的分段栈与连续栈

参考文章

1. [深入理解golang 的栈](https://www.jianshu.com/p/7ec9acca6480)
    - 图示linux的内存空间布局. 
    - C语言栈内存不够用时的两种解决方法
    - golang的分段栈与连续栈机制

linux默认的栈空间大小为8M, 可以通过`ulimit -a`查看. 在C语言中如果尝试使用在单一函数体内分配一个大于8M的数组, 那么在运行时就会出现`Segmentation fault`.

解决方法有两个: 

1. `ulimit -s 10240`调整标准库给所有线程栈分配的内存块的大小. 但是全线提高栈大小意味着每个线程都会提高栈的内存使用量, 这样一来, 你将用光所有内存. 
2. 为每个线程单独确定栈大小. 但这样一来你就不得不完成这样的任务: 根据每个线程的需要, 估算它们的栈内存的大小. 这将使创建线程的难度超出我们的期望. 

> 注意: 虽然C规定了函数栈空间的上限, 但并不是硬性分配8M给每个线程(系统的基本调度单位为线程, 所以拥有栈的是线程).

Go是如何应对这个问题的?

Go使用的解决方案类似第二种方法. 

goroutine 初始时只给栈分配很小的空间, 然后随着使用过程中的需要自动地增长. 这就是为什么Go可以开千千万万个goroutine而不会耗尽内存. 

Go 1.4 开始使用的是连续栈, 而这之前使用的分段栈. 

于是我们知道了, 分段栈与连续栈是golang为解决运行时栈空间分配的问题的机制.

下面讲述一个两者的区别

## 1. 分段栈(Segmented Stacks)

当创建一个goroutine时, Go运行时会分配一段8K的内存用于栈供goroutine运行使用. 

每个go函数在函数入口处都会有一小段代码, 这段代码会检查是否用光了已分配的栈空间, 如果用光了, 这段代码会调用morestack函数. 

### 1.1 morestack函数

morestack函数会分配一段新内存用作栈空间, 接下来它会将有关栈的各种数据信息写入栈底的一个struct中(下图中Stack info), 包括上一段栈的地址. 然后重启goroutine, 从导致栈空间用光的那个函数（下图中的Foobar）继续执行. 这就是所谓的“栈分裂 (stack split)”. 

```
+---------------+
  |               |
  |   unused      |
  |   stack       |
  |   space       |
  +---------------+
  |    Foobar     |
  +---------------+
  |  lessstack    |
  +---------------+
  | Stack info    |-----+
  +---------------+     |
                        |
  +---------------+     |
  |    Foobar     | <---+
  +---------------+
  | rest of stack |
  |               |
```

### 1.2 lessstack函数

在新栈的底部, 插入了一个栈入口函数lessstack. 设置这个函数用于从那个导致我们用光栈空间的函数(Foobar)返回时用的. 当那个函数(Foobar)返回时, 我们回到lessstack（这个栈帧）, lessstack会查找 stack底部的那个struct, 并调整栈指针(stack pointer), 使得我们返回到前一段栈空间. 这样做之后, 我们就可以将这个新栈段(stack segment)释放掉, 并继续执行我们的程序了. 

### 1.3 分段栈的问题

栈缩小是一个相对代价高昂的操作. 如果在一个循环中调用的函数遇到栈分裂 (stack split), 进入函数时会增加栈空间(morestack 函数), 返回并释放栈段(lessstack 函数). 性能方面开销很大. 

## 2. 连续栈(continuous stacks)

goroutine在栈上运行着, 当用光栈空间, 它用到与旧方案中相同的栈溢出检查. 但是与旧方案采用的保留一个返回前一段栈的link不同, 新方案创建一个两倍于原stack大小的新stack, 并将旧栈拷贝到其中. 

这意味着当栈实际使用的空间缩小为原先的大小时, go运行时不用做任何事情...类似于slice? 

栈缩小是一个无任何代价的操作（栈的收缩是垃圾回收的过程中实现的．当检测到栈只使用了不到1/4时, 栈缩小为原来的1/2）. 

此外, 当栈再次增长时, 运行时也无需做任何事情, 我们只需要重用之前分配的空闲空间即可. 

### 2.1 如何捕获到函数的栈空间不足

Go语言和C不同, 不是使用栈指针寄存器和栈基址寄存器确定函数的栈的. 

在Go的运行时库中, 每个goroutine对应一个结构体G, 大致相当于进程控制块的概念. 这个结构体中存了stackbase和stackguard, 用于确定这个goroutine使用的栈空间信息. 每个Go函数调用的前几条指令, 先比较栈指针寄存器跟g->stackguard, 检测是否发生栈溢出. 如果栈指针寄存器值超越了stackguard就需要扩展栈空间. 

### 2.2 旧栈数据复制到新栈

旧栈数据复制到新栈的过程, 要考虑指针失效问题. 

Go实现了精确的垃圾回收, 运行时知道每一块内存对应的对象的类型信息. 在复制之后, 会进行指针的调整. 具体做法是, 对当前栈帧之前的每一个栈帧, 对其中的每一个指针, 检测指针指向的地址, 如果指向地址是落在旧栈范围内的, 则将它加上一个偏移使它指向新栈的相应地址. 这个偏移值等于新栈基地址减旧栈基地址. 
