# 文件描述符,文件流和文件缓冲区

参考文章

1. [文件描述符 和 流的关系](https://blog.csdn.net/yuanzhangmei1/article/details/9131971)

## 1. 文件描述符与文件流

任何一种操作系统中, 程序在开始读写一个文件的内容之前, 必须首先在程序与文件之间建立连接或通信通道, 这一过程称为打开文件. 打开一个文件的目的可以是读或写, 也可以是既读又写. 

UNIX系统中有两种机制用于**描述程序与文件的这种连接**: 

1. 文件描述符

2. 文件流

### 1.1 文件描述符和流相同点

1. 都是用来表示用户程序与被操作文件之间的连接, 并在此连接的基础上对文件进行读写等访问. 

2. 都能表示普通文件, 设备（如终端）, 管道或套接字, 用户打开一个文件, 要么返回文件描述符, 要么返回一个流. 

3. 都包含了一大类I/O函数. 

文件描述符相关函数: open, read, write, close等

流相关函数: fopen, fread, fwrite, fclose等

### 1.2 文件描述符和流不同点: 

1.文件描述符表示为`int`类型的对象, 例如标准输入对应文件描述符为`0`, 标准输出对应文件描述为`1`;

而流则表示为指向结构FILE的指针FILE*, 因此流也称为"文件指针". open与fopen的函数原型如下:

```
int open(const char *pathname, int flags);
FILE *fopen(const char *path, const char *mode);
```

2.如果需要对**特定设备**进行控制操作, 必须使用文件描述符, 没有函数能对流进行这类操作. 

3.如果需要对特殊的方式进行I/O操作（如非阻塞方式）, 必须使用文件描述符, 因为也没有函数能对流进行这类操作. 

### 1.3 文件描述符和流的关系: 

1. 流给用户程序提供了更高一级的（功能更强大, 使用更简化）的I/O接口, 它处在文件描述符方式的上层, 即, 流函数是通过文件描述符函数来实现的. 

2. 流函数提供格式化输出, 扫描输入和设备缓冲. 

3. 流函数有利于程序的移植, 任何基于ANSI C的系统都支持流, 而对文件描述符的支持则较弱. 

## 2. 缓冲区机制

### 2.1 对缓冲区的认识

根据应用程序对文件的访问方式, 即是否存在缓冲区, 对文件的访问可以分为带缓冲区的操作和非缓冲区的文件操作: 

1. 缓冲区文件操作: 高级文件系统, 对应文件流. 将在用户空间中自动为正在使用的文件开辟内存缓冲区. 

2. 非缓冲区文件系统: 低级文件系统, 对应文件描述符, 所提供函数为系统调用(open, read). 如果需要, 只能由用户在自己的程序中为每个文件设定缓冲区. 

若采用非缓冲的文件访问方式, 每次对该文件进行一次读写操作时, 都需要使用读写文件系统掉用来处理该操作. 因此, 如果用户需要访问某个磁盘文件, 则每访问一次都要执行一次系统调用, 执行一次系统调用将涉及到CPU状态的切换, 即从用户空间切换到内核空间, 实现上下文的切换, 这将损耗一定的CPU时间, 频繁的磁盘访问对程序的执行效率造成很大的影响. 

ANSI标准C库函数建立在底层系统调用之上, 即C函数库文件访问函数的实现中使用了低级文件I/O系统调用, ANSI标准C库中的文件处理函数为了减少使用系统调用的次数, 提高效率, 根据应用的不同, 采用缓冲区机制, 这样, 在对磁盘文件进行读操作时, 可以一次从文件中读出大量的数据到缓冲区中, 以后对这部风的访问就不需要在使用系统调用了, 即只需要少量的CPU状态切换. 在对文件进行写操作时, 可以先将内容存在缓冲区, 待文件写满后, 或者确实需要更新时在调用系统调用将文件一次写入到磁盘中. 

### 2.2 缓冲区类型

标准I/O提供了3种类型的缓冲区: 

1. 全缓冲: 这种缓冲区要求填满整个缓冲区后才进行I/O系统调用操作. 对于磁盘文件通常使用全缓冲区访问. 第一次执行I/O操作时, ANSI标准的文件管理函数通过调用malloc函数获得需要使用的缓冲区. 默认大小为81992. 

2. 行缓冲区: 在这种情况下, 当在输入和输出中遇到换行符时, 标准 I/O 库执行 I/O系统调用操作. 当流涉及一个终端时(例如标准输入和标准输出), 使用行缓冲区. 因为标准I/O 库收集的每行的缓冲区长度是固定的, 只要填满了缓冲区, 即使还没有遇到换行符, 也将执行 I/O 系统调用操作. 默认行缓冲区大小为 128 字节. 

3. 无缓冲区: 标准 I/O 库不对字符进行缓存. 如果用标准 I/O 函数写若干字符到不带缓冲区的流中, 则相当于用 write 系统调用函数将这些字符写至相关联的打开文件. **标准出错流 stderr 通常是不带缓冲区的, 这使得出错信息能够尽快地显示出来**. 


对于标准输入输出设备, ANSI C 要求具有以下缓冲区特征: 

- 标准输入和标准输出设备: 当且仅当不涉及交互作用设备时, 标准输入流和标准输出流才是全缓冲区的. 

- 标准错误输出设备: 标准错误决不会是全缓冲区的. 

**对于任何一个给定的流, 可以调用 setbuf()和 setvbuf()函数更改其缓冲区类型. **