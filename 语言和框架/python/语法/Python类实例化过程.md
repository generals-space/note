# Python类实例化过程

参考文章

1. [Python 中特殊变量/方法命名规则说明(特别是私有变量)及使用实例](http://www.cnblogs.com/king-sun/p/4361998.html)

2. [python中的__init__ 、__new__、__call__小结](http://www.jb51.net/article/49375.htm)

3. [python特殊函数 __call__()](http://www.cnblogs.com/superxuezhazha/p/5793536.html)

------

1. `__new__(cls, *args, **kwargs)`: 创建对象时调用, 在`__init__`之前执行, 返回当前对象的一个实例. 注意：这里的第一个参数是`cls`, 即`class`对象本身

2. `__init__(self, *args, **kwargs)`: 创建完对象后调用, 对当前对象的实例的一些初始化, 无返回值,即在调用`__new__`之后, 根据返回的实例初始化；注意, 这里的第一个参数是`self`即对象本身, 注意和`__new__`的区别.

3. `__call__(self,  *args, **kwargs)` 如果类实现了这个方法, 相当于把这个类的实例对象当函数来使用, 相当于重载了括号运算符.

在类实例化过程中, 三者的调用顺序为new -> init [-> call].

## 1. new

关于`__new__`的原理, 参考文章2解释的十分详细.

`__new__()`是在新式类中新出现的方法, 所以它要求其顶级父类必须继承`object`, 它在构造方法建造实例之前执行. 可以这么理解, 在Python中存在于类里面的构造方法`__init__()`负责将类的实例化, 而在`__init__()`执行之前, `__new__()`决定是否要使用该`__init__()`方法, 因为`__new__()`可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例. 

如果将类比喻为工厂, 那么`__init__()`方法则是该工厂的生产工人, `__init__()`方法接受的初始化参数则是生产所需原料, `__init__()`方法会按照方法中的语句负责将原料加工成实例以供工厂出货. 而 `__new__()`则是生产部经理, `__new__()`方法可以决定是否将原料提供给该生产部工人, 同时它还决定着出货产品是否为该生产部的产品, 因为这名经理可以借该工厂的名义向客户出售完全不是该工厂的产品. 

`__new__()`方法的特性：

1. `__new__()`方法是在类准备将自身实例化时调用. 

2. `__new__()`方法始终都是类的静态方法, 即使没有被加上静态方法装饰器. 

在`__new__()`方法中, 如果要得到当前类的实例，应当在当前类中的`__new__()`方法语句中调用当前类的父类的`__new__()`方法。

例如，如果当前类是直接继承自`object`，那当前类的`__new__()`方法返回的对象应该为：

```py
class A(object):
    def __new__(cls, *args, **kwargs):
        ## ...
        return object.__new__(cls, *args, **kwargs)
        ## 直接父类不是object时
        ## return super(A, cls).__new__(cls, *args, **kwargs)
```

事实上我们一般不会重写`__new__()`方法, 即在定义新式类时没有重新定义`__new__()`时，Python默认是调用该类的直接父类的`__new__()`方法来构造该类的实例，如果该类的父类也没有重写`__new__()`，那么将一直按此规矩追溯至`object`的`__new__()`方法，因为`object`是所有新式类的基类。

而如果新式类中重写了`__new__()`方法，那么你可以自由选择任意一个的其他的新式类（必须要是新式类，只有新式类才都有`__new__()`，因为所有新式类都是`object`的后代，而经典类则没有`__new__()` 方法）的`__new__()`方法来制造实例，包括这个新式类的所有前代类和后代类，只要它们不会造成递归死循环。

实例一发

```py
class A(object):
    def __new__(cls, *args, **kwargs):
        print('making...')
        return object.__new__(cls, *args, **kwargs)
    def __init__(self):
        print('initing...')

a = A()
```

**注意**

在`__new__`方法中不能`return`类本身的`__new__()`, 如上面A类中`return A.__new__(cls, *args, **kwargs)`, 会死循环的.

`__new__`方法中可以直接通过`类名.__new__(cls...)`创建实例, 这里的类名可以是完全无关的前代或后代类, 只要不死循环...

...你想过`__init__`能这么干嘛? 当然不行...

## 2. init

...init没什么好说的

## 3. call

简单来说, 就是`__call__()`方法能够让类的实例对象, 像函数一样被调用.

比如

```py
a = A()         ## 实例化A类
a()             ## 如果为A类定义了`__call__()`方法, 就可以这么用了
```

实例

```py
#!/usr/bin/env python
#!encoding: utf-8

class A(object):
    def __call__(self, x):
        print '__call__ called, print x: ', x

a = A()
a('general')            ## __call__ called, print x:  general
```

在没实现`__call__`方法时, 你有想过这么用吗?