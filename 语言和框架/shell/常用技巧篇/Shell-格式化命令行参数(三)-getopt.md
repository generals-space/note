# Shell-格式化命令行参数(三)-getopt

`getopt`是`util-linux-ng`包中的工具, 不过大多数发行版默认安装了这个工具. 它是增强型的`getopts`, 可以处理长选项.

先来一个示例, 将以下脚本命名为`test1.sh`, 之后的讲解基于这个示例.

```bash
#!/bin/bash
echo '初始参数列表:' $@
## --是结束标志, 命令行中的参数解析完毕后, 会执行case语句中对应的匹配项
## $@为传入脚本的参数列表, getopt会对其进行解析并重新排序, ARGS是getopt重新排序后的参数列表字符串, 可以通过echo查看
ARGS=$(getopt -o a:c:b -l a-long:,c-long:,b-long -- "$@")
## `set -- 变量列表`, 会把变量列表中的变量按顺序赋值给$1, $2...相当于重写传入脚本的参数列表
eval set -- "${ARGS}"
echo '解析后的参数列表:' $@

while true
do
	case $1 in
		-a|--a-long)
			echo 'a选项是有参数的, 这里取到它的参数为: ' $2
			## 参数列表左移2位
            shift 2
			;;
		-c|--c-long)
			echo 'c选项是有参数的, 这里取到它的参数为: ' $2
			## 参数列表左移2位
            shift 2
			;;
		-b|--b-long)
			echo 'b选项无参'
			## 参数列表左移1位
            shift 1
			;;
		## '--'结束标记, 与ARGS=$(...)中的'--'对应
		--)
			shift 1
			break
		;;
		*)
			echo "invalid option"
			return 1
		;;
	esac
done
```

## 1. 参数列表规则

`ARGS=$(getopt -o a:c:b -l a-long:,c-long:,b-long -- "$@")`

这一句就是将传入脚本的参数列表`$@`交给`getopt`解析. 关于可选选项参数列表的定义, `getopt`有两个选项.

- `-o/--option`: 普通短选项

- `-l/--long`: 长选项

还有一些其他的选项

- `-n`: 错误信息的提示符, 如`-n 'invalid option: '`

- `-a`: 使长参数支持'-'符号开头(而不是'--'), 必须与`-l`同时使用

冒号的使用与`getopts`类似, 不带冒号的字符表示不需要参数, 带有一个冒号的字符表示需要一个参数, 还有带两个冒号的选项, 这个在后面会讲到.

需要注意的是长选项需要使用逗号','分隔.

## 2. 参数列表顺序

`getopt`与`getopts`不同, `getopts`不会修改传入脚本的参数列表顺序, 如果中间混有多余的参数, 就会出错或停止解析; 而`getopt`需要对参数列表重新排序, 将多余参数移至最后, 程序可以对多余参数继续解析.

比如

```
$ ./test1.sh -a abc now -c 123
初始参数列表: -a abc now -c 123
解析后的参数列表: -a abc -c 123 -- now
a选项是有参数的, 这里取到它的参数为:  abc
c选项是有参数的, 这里取到它的参数为:  123
```

遇到非法选项就不是这样了, 未在参数列表中列出的选项, 会在`case`语句中匹配到`*)`这一段, 不过如果不在这里写`return`/`exit`语句的话, 也不会强制退出脚本的. 可以看到, 其实第2个`$@`的输出也得到了正确的参数列表.

比如

```
./test1.sh -a abc -d -c 123
初始参数列表: -a abc -d -c 123
getopt: invalid option -- 'd'
解析后的参数列表: -a abc -c 123 --
a选项是有参数的, 这里取到它的参数为:  abc
c选项是有参数的, 这里取到它的参数为:  123
```

------

关于`getopt`对参数列表顺序的修改, 需要理解`eval set -- "${ARGS}"`这一句. 

在这句之前打印ARGS的值, 如`echo $ARGS`. 

执行`./test1.sh -a abc -d -c 123`, 得到其输出为`-a 'abc' -c '123' --`, 与解析后的参数列表的输出是相同的. 

那这句`set -- ...`有什么作用呢?

将如下脚本保存为`test2.sh`. 

```bash
#!/bin/bash

set -- a b c
echo $1 $2 $3
```

直接执行, 不要加任何参数.

```
$ ./test2.sh 
a b c
```

可以看到, `set`配合`--`选项将其后面的参数赋值给了`$1`, `$2`..这些变量. `getopt`脚本中也是这样. 它将经过`getopt`解析的参数列表重新给`$1`,`$2`赋值, 于是之后的`while`循环可以通过`$1`,`$2`取得选项名称及参数值.

### 3.3 while循环与shift

`getopt`没有`getopts`中类似于`$OPTIND`的变量, 无法自动移动游标. 要维持循环, 需要使用`shift`将参数左移.

比如, 执行`./test1.sh -a abc now -c 123`. 经过解析的参数列表为`-a abc -c 123 -- now`.

在while循环中, 此时$1=-a, $2=now. 匹配到`case`语句中的判断条件后, `shift 2`将参数列表左移2位, 参数列表变为`-c 123 -- now`.

循环继续, 此时$1=-c, $2=123. 匹配到`case`语句中的判断条件, `shift 2`将参数列表左移2位, 参数列表变为`-- now`.

遇到`--`参数列表左移1位, 说明合法参数列表正常解析完毕, 跳出循环. 这里左移1位是为了让脚本剩余部分可以解析命令行剩余的参数, 这里只剩下了'now'参数.
