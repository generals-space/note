# Shell脚本元素-各种括号(一)-小括号

参考文章

1. [shell中的括号（小括号, 中括号, 大括号）](http://blog.csdn.net/tttyd/article/details/11742241)

2. [shell中的各种括号](http://blog.csdn.net/weihongrao/article/details/17007575)

3. [linux中双括号和双中括号, 括号和中括号](http://blog.csdn.net/weihongrao/article/details/17006931)

4. [shell脚本中的几个括号总结(小括号/大括号/花括号)](http://blog.csdn.net/lee244868149/article/details/38422437)

5. [shell编程中常用的比较、判断和删除等语法](http://blog.csdn.net/lee244868149/article/details/38424267)

6. [GNU Linux shell中如何进行各进制编码间(二进制、8进制、16进制、base64)的转换](https://blog.csdn.net/yygydjkthh/article/details/50699913)

> 小括号 == (圆括号)

## 1. 单小括号

### 1.1 命令组

括号中的命令将会新开一个子shell并顺序执行, 所以**括号中可以引用括号外面的变量, 但括号内定义的变量不能够被括号外面的部分使用, 并且括号中对外面变量的修改也不会生效**. 括号中多个命令之间用分号隔开, 最后一个命令可以没有分号, 括号与之后的命令之间也需要有分号, 各命令和括号之间不必有空格. 

```
## 括号中可以引用括号外面的变量
$ x1='123'
$ (echo $x1)
123

## 括号内定义的变量不能够被括号外面的部分使用
$ (x2='321')
$ echo $x2

## 括号中对外面变量的修改也不会生效
$ x1='123'
$ (x1='abc'; echo $x1); echo $x1
abc
123
```

### 1.2 命令替换

等同于反引号`cmd`, shell扫描一遍命令行, 发现了`$(cmd)`结构, 便将`$(cmd)`中的cmd执行一次, 得到其标准输出, **再将此输出放到原来命令行中**. 有些shell不支持, 如tcsh. 

```
$ xy=$(echo '123')
$ echo $xy
123
```

### 1.3 用于初始化数组

```
$ array=(a b c def)
$ echo ${array[2]}
c
$ echo ${array[3]}
def
```

## 2. 双小括号

> `((exp))`这种计算是符合C语言的运算符, 也就是说只要符合C的运算符都可用在`((exp))`, 甚至是三目运算符. 注意: 这种扩展计算是整数型的计算, 不支持浮点型. 若是逻辑判断, 表达式exp为真则为1,假则为0. 

### 2.1 整数运算

1. 四则运算: 加减乘除, 求余. (不过没有办法设置精度, 除法只能保留整数部分), 可用括号

2. 位运算: 与(&), 或(|), 非(^); 

3. 数值比较: `>` `<`, `>=` `>=`, `==` `!=`, 与(&&), 或(||), 返回值为1/0(真或假).

4. 三目运算符: (( 1 ? 2: 3))

5. 进制转换

**注意**

1.  **内容只可以是数字, 且只可以是整数**

2.  如果要将双小括号的结果赋值给变量, 需要使用`$`运算符, 如`$((1 + 2))`; 或是直接在双小括号内部完成赋值, 如`((num = 1 + 2))`

3. 双括号内外共享变量, 内部还可以使用自增(`++`), 自减(`--`)运行符; 另外, **双括号内部引用变量时不可以加`$`符号**

4. 双小括号内的表达式支持空格;

#### 2.1.1 简单运算

简单运算并赋值

```
$ echo $((1 + 2))
3
$ ((num = 1 + 2))
$ echo $num
3
```

真值运算, 返回值只能是0或1.

```
$ echo $(( 2 || 1))
1
$ echo $((1 > 2))
0
```

自增运算

```
$ a=1
$ ((a ++))
$ echo $a
2
```

#### 2.1.2 三目运算

三目运算, 不过好像没多大用, 只能进行数据运算

```
$ echo $(( 1==2 ? 4 : 7))
7
```

如果第一个参数是空字符串或0, 就返回第3个参数的值(即认为这个条件为假);反之, 就返回第2个参数串的值. 

但前提是, 第2, 3个参数为数值类型, 如果它们是字符串, 那就会返回0

```
$ a=123
## 在双小括号内部, 变量a不用加$符
$ echo $(( a ? 8 : 9 ))
8
$ a=
$ echo $(( a ? 8 : 9 ))
9

$ a=123
## 貌似原因是abc被当作了变量, 所以返回0
$ echo $(( a ? abc : def ))
0
## 但是不能将abc, def赋值为字符串, 双小括号会认为存在语法错误...这个可能比较难以理解, 不建议日后使用
$ abc='abc'
$ echo $(( a ? abc : def ))
-bash: abc: expression recursion level exceeded (error token is "abc")
```

#### 2.1.3 进制转换

按照参考文章6, 十分有效.

双小括号内部的数值默认以10进制处理, 不过可以通过与其他高级语言相似的前缀来声明变量的进制. 如以`0`开头即为8进制, 以`0x`开头即为16进制. 使用 `BASE#NUMBER`这种形式可以表示其它进制.

> BASE取值范围：2-64

八进制转十进制

```
$ ((num = 020)); echo $num
16
$ ((num = 8#20)); echo $num
16
```

十六进制转十进制

```
$ ((num = 0xff));echo $num
255
$ ((num = 16#ff));echo $num;
255
```

这里只是其他进制转十进制的方法, 至于其他进制互转的方法, 可以使用`bc`命令.

### 2.2 扩展C语言流程控制语法

这一节与单中括号与单大括号相关, 建议先了解这两者的用法.

默认情况下, shell中的条件判断如`if`, `while`, `for`的语法类似于

```
## if [ 1 = 1 ]; then shell命令; fi
if [ 1 == 1a ]; then echo yes; else echo no; fi
## for i in {1..10}; do shell命令; done
for i in {1..10}; do touch test$i.txt; done
## while [ a -lt 10 ]; do shell命令; done
while [ $a -lt 10 ]; do echo $a; ((a++)); done
```

有了`(())`, 可以使用类似于C语言的循环语句

**if**

```
## 默认[]中是不可以使用`&&`与`||`操作符, 并且数值比较不能使用> < =等符号的, 双小括号中可以, 这一点与双中括号类似
$ if (( 'abc' == 'abc' || 1 == 2 )); then echo yes; else echo no; fi
yes
$ if [[ 'abc' == 'abc' || 1 == 2 ]]; then echo yes; else echo no; fi
yes
```

**for**

```
$ for ((a=0; a<10; a++)); do echo $a; done
0
1
2
3
4
5
6
7
8
9
```

```
$ a=0
$ while ((a<10)); do echo $a; ((a++)); done
0
1
2
3
4
5
6
7
8
9
```

> 在作判断条件时, 双括号中的内容不再局限于数字, 也可以是字符串.
