# Nginx变量漫谈(二)-Nginx变量的作用域与生存时间

## 2.1 作用域

`set`指令(以及前面提到的`geo`指令)不仅有赋值的功能, 它还有创建Nginx变量的副作用, 即当作为赋值对象的变量尚不存在时, 它会自动创建该变量. 比如在前面的例子中, 如果`$a`这个变量尚未创建, 则`set`指令会自动创建`$a`这个用户变量. 如果我们不创建就直接使用它的值, 则会报错. 例如:

```
server {
    listen 8080;

    location /bad {
        echo $foo;
    }
}
```

此时Nginx服务器会拒绝加载配置:

```
[emerg] unknown "foo" variable
```

是的, 我们甚至都无法启动服务!

有趣的是, Nginx变量的创建和赋值操作发生在全然不同的时间阶段. **Nginx变量的创建只能发生在Nginx配置加载的时候, 或者说Nginx启动的时候; 而赋值操作则只会发生在请求实际处理的时候.** 这意味着不创建而直接使用变量会导致启动失败, 同时也意味着我们无法在请求处理时动态地创建新的Nginx变量.

**Nginx变量一旦创建, 其变量名的可见范围就是整个Nginx配置, 甚至可以跨越不同虚拟主机的server配置块**.

来看一个例子:

```
server {
    listen 8080;

    location /foo {
        echo "foo = [$foo]";
    }

    location /bar {
        set $foo 32;
        echo "foo = [$foo]";
    }
}
```

这里我们在`location /bar`中用`set`指令创建了变量`$foo`, 于是在整个配置文件中这个变量都是可见的, 因此我们可以在`location /foo`中直接引用这个变量而不用担心Nginx会报错.

下面是在命令行上用`curl`工具访问这两个接口的结果:

```
$ curl 'http://localhost:8080/foo'
foo = []
 
$ curl 'http://localhost:8080/bar'
foo = [32]
 
$ curl 'http://localhost:8080/foo'
foo = []
```

从这个例子我们可以看到, `set`指令因为是在`location /bar`中使用的, 所以赋值操作只会在访问`/bar`的请求中执行. 而请求`/foo`接口时, 我们总是得到空的`$foo`值, 因为用户变量未赋值就输出的话, 得到的便是空字符串.

从这个例子我们可以窥见的另一个重要特性是, **Nginx变量名的可见范围虽然是整个配置, 但每个请求都有所有变量的独立副本**, 或者说都有各变量用来存放值的容器的独立副本, 彼此互不干扰. 比如前面我们请求了`/bar`接口后, `$foo`变量被赋予了值32, 但它丝毫不会影响后续对`/foo`接口的请求所对应的`$foo`值(它仍然是空的!), 因为各个请求都有自己独立的`$foo`变量的副本.

对于Nginx新手来说, 最常见的错误之一, 就是将Nginx变量理解成某种在请求之间全局共享的东西, 或者说"全局变量". 而事实上, **Nginx变量的生命期是不可能跨越请求边界的**.

## 2.2 生命期

关于Nginx变量的另一个常见误区是认为变量容器的生命期, 是与`location`配置块绑定的. 其实不然. 我们来看一个涉及"内部跳转"的例子:

```
server {
    listen 8080;

    location /foo {
        set $a hello;
        echo_exec /bar;
    }

    location /bar {
        echo "a = [$a]";
    }
}
```

这里我们在location /foo中, 使用第三方模块ngx_echo提供的echo_exec配置指令, 发起到location /bar的"内部跳转". 所谓"内部跳转", 就是在处理请求的过程中, 于服务器内部, 从一个location跳转到另一个location的过程. 这不同于利用HTTP状态码301和302所进行的"外部跳转", 因为后者是由HTTP客户端配合进行跳转的, 而且在客户端, 用户可以通过浏览器地址栏这样的界面, 看到请求的URL地址发生了变化. 内部跳转和Bourne Shell(或Bash)中的exec命令很像, 都是"有去无回"(另一个相近的例子是C语言中的goto语句).

既然是内部跳转, 当前正在处理的请求就还是原来那个, 只是当前的location发生了变化, 所以还是原来的那一套Nginx变量的容器副本. 对应到上例, 如果我们请求的是/foo这个接口, 那么整个工作流程是这样的: 先在location /foo中通过set指令将$a变量的值赋为字符串hello, 然后通过echo_exec指令发起内部跳转, 又进入到location /bar中, 再输出$a变量的值. 因为$a还是原来的$a, 所以我们可以期望得到hello这行输出. 测试证实了这一点:

```
$ curl localhost:8080/foo
a = [hello]
```

但如果我们从客户端直接访问`/bar`接口, 就会得到空的`$a`变量的值, 因为它依赖于`location /foo`来对`$a`进行初始化.

从上面这个例子我们看到, 一个请求在其处理过程中, 即使经历多个不同的`location`配置块, 它使用的还是同一套Nginx变量的副本. 这里, 我们也首次涉及到了`内部跳转`这个概念. 值得一提的是, 标准`ngx_rewrite`模块的`rewrite`配置指令其实也可以发起`内部跳转`, 例如上面那个例子用rewrite配置指令可以改写成下面这样的形式:

```
server { 
    listen 8080; 
    location /foo { 
        set $a hello; 
        rewrite ^ /bar; 
    } 
    location /bar { 
        echo "a = [$a]"; 
    } 
}
```

其效果和使用`echo_exec`是完全相同的. 后面我们还会专门介绍这个`rewrite`指令的更多用法, 比如发起301和302这样的`外部跳转`.

从上面这个例子我们看到, Nginx变量值容器的生命期是与当前正在处理的请求绑定的, 而与location无关.