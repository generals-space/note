# C语言-字节对齐

结构体与类对象都存在字节对齐的说法, 甚至所有的变量在内在中的存储也有对齐一说.

实际上, 这种对齐是为了在空间与复杂度上达到平衡的一种技术手段.

简单来说, 就是在可接受的空间浪费的前提下, 尽可能提高对相同运算过程的最快处理.

## 1. 必要性

假设机器字长(CPU位数)是32, 即处理任何内存中的数据, 都是按32位的单位进行的.现有两个变量:

```
char A;
int B;
```

假设这两个变量是从内在地址0开始分配, 如不考虑对齐, 应是这样存储的(以intel的小端序为例):

![](http://img.generals.space/65de997f4c19cc3c7cd0374a2c2d9de9.png)

因为计算机字长是4字节, 所以在处理变量A与B时的过程可能大致为:

A: 将0x00-0x03(共32位)读入寄存器, 再通过与0x000000FF做与运算得到(即只取其后8位, 因为char类型只是一个字节);

B: 将0x00-0x03(共32位)读入寄存器, 并通过位运算得到低24位的值; 再将0x04-0x07(共32位)读入寄存器, 通过位运算得到高8位的值; 然后与前面得到的值再做位运算, 得到int类型的32位的值.

由上面叙述可知, 对A的处理较为简单, 但对B, 其本身是32位, 处理时却要拆成2部分, 之后再合并, 效率上就有些低了. 为了解决这个问题, 就需要付出几个字节的代价, 改为下图的分配方式:

![](http://img.generals.space/6aea738b24b5bde0a9a405206e2815e2.png)

## 2. 计算原则

前提:在没有`#pragma pack`宏的情况下, 计算结构体的实际大小

1. 数据成员对齐规则: 结构体struct或联合体union的数据成员, 第一个数据成员放在offset为0的地方, 以后每个数据成员存储的起始位置要从该成员(指当前成员而非第一个成员)大小或该成员的子成员大小(比如数组和结构体等)的整数倍开始(比如int为4字节, 则要从4的整数倍开始存储).

2. 结构体作为成员: 如果一个结构里有某些结构体成员, 则结构体成员要从其内部最大元素大小的整数倍地址开始存储(struct A中存有struct B, B中有char, int, double等元素, 那B在A中应从8的整数倍开始存储).

3. 收尾工作: 结构体的总大小(亦即sizeof的结果), 必须是其内部最大成员的整数倍, 不足的要补齐

## 3. 深层解析

系统默认的对齐原则, 就是为了追求两点:

变量的最高效加工
达到目的1的最少空间
以一个结构体为例:

```c
struct T
{
    char c;    //1Byte
    __int64 d; //8Bytes
    int e;     //4Bytes
    short f;   //2Bytes
    char g;    //1Byte
    short h;   //2Bytes
}
```

假设定义了一个结构体变量C, 在内存中分配到0x00的位置

对于成员C.c, 无论如何, 也是一次寄存器读入, 所以先占用一个字节;

对于成员C.d, 8字节变量, 如果紧跟C.c存储, 则需要读入寄存器至少3次, 为实现最少的读入次数(2次), 至少需要4字节对齐; 然而对于8字节原始变量, 为了在寻址单位上统一, 则需要按8字节, 所以, 应该分配到0x08-0x0F;(如此解释了原则1)

对于成员C.e, 4字节变量, 只需满足分配起始为4的整数倍即可, 所以分配到0x10-0x13;

对于成员C.f, 2字节变量, 直接分配在0x14-0x15, 这样, 只需一次读入寄存器后加工, 边界也已与2对齐;

对于成员C.g, 1字节变量, 直接分配到0x16

对于成员C.h, 2字节变量, 为保证是2的整数倍, 所以应分配到0x18-0x19的位置

分配图如下(暂时还不正确, 耐心读下去):

![](http://img.generals.space/8aede96ac98d653da3d2111fbe3a7ba2.png)

貌似已经结束了, 但如果定义一个结构体数组CAarray[2], 按变量分配原则, 这两个结构体应该是在内存中连续存储的, 分配应如下图:

![](http://img.generals.space/c45ef8ae5cc65f0bf735bcc2bb92f4df.png)

由上图可知, CArray[1]的很多成员都不再对齐了, 究其原因, 是结构体的开始边界不对齐. (如此解释了原则3)

上述结构体应按最长的成员d对齐, 即应是8的倍数, 正确的分配图如下:

![](http://img.generals.space/b3853bc1ed391f52d35bd9e951d53b6f.png)

> 注意: 不同编译环境下可能会出现不同的结果, 比如Linux下的GCC与Windows下VS/VC之类的编译器产生的结果有可能不一样, 这会涉及到#pargam pack()宏.

## 4. 关于`#pragma pack`宏

四个概念：

1. 数据类型自身的对齐值：基本数据类型的自身对齐值，等于sizeof(基本数据类型)。

2. 指定对齐值：#pragma pack (value)时的指定对齐值value。

3. 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。

4. 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小的那个值。

有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的"存放起始地址%N=0".而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是 数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整 数倍)

`#pragma pack (value)`告诉编译器，使用我们指定的对齐值来取代缺省的。

如

```
#pragma pack (1) /*指定按2字节对齐*/
#pragma pack () /*取消指定对齐，恢复缺省对齐*/
```

Vc,Vs等编译器默认是#pragma pack(8), gcc默认是#pragma pack(4), 并且gcc只支持1, 2, 4对齐.