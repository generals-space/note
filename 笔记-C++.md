# 笔记-C++

## 1. 引用声明符&与取地址符&的区别

作用：

前者用来传值，后者用来获取变量首地址

&(引用)出现在变量声明语句中，位于变量左边，表示声明的是引用类型

&(取地址)应用在给变量赋初值时，位于等号右边，或在执行语句中作为一元运算符出现时表示取对象的地址

示例：

1. 引用在' = '左边，取地址符在' = '右边。如：

```c
int a = 3;
int &b = a;//引用，b为引用(别名)
int *c = &a;//取地址，c为指针
```
 
2. 和类型在一起的是引用，和变量在一起的是取址。如：

```c
int function(int &i)//这里i是引用类型
{

}
```

## 2. 初始化与赋值

区别：

- 变量在定义时就进行赋值叫做初始化；

- 变量定义完后，在之后的语句进行赋值，叫做赋值

### 2.1 const对象和引用类型

这两种类型的...前者应该叫作"对象"，后者应该叫作"变量"，一旦创建，其值就不能再改变，即不能被赋值，所以必须在创建的同时进行初始化。

```
int a = 2;
//int& b; //这句话是错误的，因为引用类型b未经初始化
int& b = a;//正确

//const int z; //错误，const类型对象也应被初始化
const int z = 10;
```

#### 2.2 指针对象

指针对象可以在创建的同时进行初始化，也可以在创建之后进行赋值(在使用一个指针变量之前其必须指向一个已存在的地址，否则会出错)

```
int a = 2;
int *p = &a;//声明时初始化
int *q;
q = &a;//对指针变量赋值
```

### 2.3 数组和结构体

数组，结构体只支持创建时初始化，或者创建后按索引，字段赋值

```
typedef struct tt {
        int sum;
        int rv;
}TT;

int main() {
        TT test;
        //test = {1, 10}; // 此句错误
        TT test1 = {1, 10};
        return 0;
}
```

类似的，数组赋值也有同样的问题

```
int a[5] = {1, 2, 3, 4, 5};
int b[5];
//b = {1, 2, 3, 4, 5};//这句是错的
```

## 3. 关于模板编译

模板不支持分离编译，声明和定义应全都写在头文件中，不然会出现类似如下的错误：

```shell
main.cpp:(.text+0x50): undefined reference to 'X<int>::X()'
```

说明：当编译器遇到一个模板定义时，不会生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。

## 4. 类中的静态成员变量初始化方式

可在类外直接赋值，如：

```c++
class A{
    static int xy;
}
A::xy = 2;
```

说明：所有class A的实例共享同一个变量xy。

注意：这种初始化的方式适用于public和private类型，但是初始化完毕之后依然只有类的成员函数才能访问。

## 5. 关于引用

- 引用是复合类型

- 引用非对象

- 引用即别名

- 引用无法重新赋值，即引用无法绑定到其他对象

- 由于上一点，引用声明时必须被初始化

- 引用的地址与其绑定的对象的地址相同

## 6. 关于const

const对象一旦创建，其值就不能再改变，所以const对象必须初始化(这一点与引用型变量类似)。

编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，使得它成为编译期间的常量，没有存储与读内存的操作，效率也会变高。

## 7. 关于static

- 父类的静态成员变量可以被子类继承，但不相关，即子类可单独修改而不影响父类的静态变量。

- 类的静态成员函数不允许使用非静态成员变量。

- 类中已经声明为static类型的成员函数，在类外定义时不能再加static关键字。

- public类型的类静态成员变量，可以在类外初始化"类型名 类名::变量名 = 变量值"，也可以在别的函数通过"类名::变量名"进行访问和操作。

- private，protected类型的类静态成员变量进行初始化(方法同public)，但不能再通过"类名::变量名"进行访问和操作。不过可以定义public类型的静态成员函数，在类外(类内也可以)通过"类名::函数名"进行访问和操作。或者也可以实例化类的对象，将此函数当作普通成员函数一样调用来访问和操作该静态成员变量。

## 8.

C语言中定义一个struct类型，例如struct Student，用它去声明一个变量时，需要用struct Student student，必须要有struct关键字修饰，但是C++不需要(可以想想class)，其他如union和enum也是一样。

## 9. 

用`*`取一个string迭代器类型的值，类型是char，不是char*也不是string

## 10.

函数可以以`引用`/`指针`的方式返回局部变量，但是无法使用，因为局部变量在该函数执行完毕时就销毁了，返回的东西是无效的，强制使用只会出错。

## 11. 函数默认参数

使用方法为:

**1. 单个参数**

```
void f1(int _x = 5);
```

调用时f1()或者f1(2)皆可.

**2. 多个参数**

```
void f2(int _x = 5, float y = 4);
```

调用时`f2()`或`f2(3)`或者`f2(3, 5.0)`皆可

> 注意: 实参与形参的结合是从左至右顺序进行的, 因此指定默认值的参数必须放在形参列表中的最右端, 不可分隔. 如:

```
void f3(int _a, int _b = 0, int _c, char _d = 'a');//不正确

void f3(int _a, int _c, int _b = 0, char _d = 'a'); //正确
```

而且, C语言不支持默认参数

## 12. 前向声明

> 在程序设计中,前向声明(Forward Declaration)是指声明标识符(表示编程的实体,如数据类型、变量、函数)时还没有给出完整的定义。

### 12.1 含义

前向声明就是：声明一个类而不定义它.

```c++
class Screen;//declaration of the Screen class
```

这个声明,有时候被称为`前向声明`(forward declaration),在程序中引入了类类型的`Screen`.在**声明之后,定义之前**, 类Screen是一个不完全类型(incompete type),即已知Screen是一个类型,但不知道包含哪些成员.

不完全类型只能以有限方式使用, 不能定义该类型的对象,不完全类型只能用于**定义指向该类型的指针及引用**, 或者用于**声明(而不是定义)使用该类型作为形参类型或返回类型的函数**.

### 12.2 用途

两个类需要相互引用或相互成为类中的子对象成员时，就无法先定义使用，在编译环节就出现错误导致编译失败，这时就需要用到前向声明，此外，前向声明的类不能被实例化。

示例：

文件`A.h`中

```c
#ifndef  _A_H
#define _A_H
#include "B.h"
class A
{
    public:
        A(void);
        ~A(void);
        B b_; //A类中包含B类对象
};
#endif
```
文件`B.h`中

```c++
#ifndef _B_H
#define _B_H

/*B类包含A类对象，A类又包含B类对象时，头文件也互相包含，这是不允许的，需要前向声明：
在B.h中将A类前向声明，此时就不再需要包含A.h头文件，且B中不能有A类的对象，
因为前向声明的类不能被实例化，但是可以是A类的指针或者引用*/

//#include "A.h"  
class A;
class B
{
public:
    B(void);
    ~B(void);
    //A a_;  //前向声明后，B类中不能含有A的对象
    A *a_;   //可以是指针
    void Fun(A &a )  //可以是引用
     {
    }
};
#endif
```

## 13 super关键字的替代(待深究)

问题描述：子类如何调用父类的非静态成员函数？

C++支持多重继承，所以super无法得到究竟是哪一个父类的同名方法。

解决办法：

在子类内部，可以直接通过"父类名::方法名()"调用
在子类外，可以通过实例化一个子类对象，使用"对象名.父类名::方法名()"调用。
示例：

```
#include <iostream>
using namespace std;
class Parent
{
        //暂时不能有构造函数
        public:
                //name暂时不能设置为private类型，涉及到私有继承等方式
                string name;
                void setStr(string name);
                string getStr();
};
void Parent::setStr(string name)
{
        this->name = name;
}
string Parent::getStr()
{
        return this->name;
}
class Child : public Parent
{
};
int main()
{
        Parent parent;
        parent.setStr("general");
        cout << parent.getStr() << endl;

        Child child;
        child.setStr("jiangming");
        cout << child.getStr() << endl;

        //如此看来,child.Parent也是一个对象了，相当于经过实例化一样,可以保存变量
        child.Parent::setStr("lianqia");
        cout << child.Parent::getStr() << endl;//这句是关键
        return 0;
}
```