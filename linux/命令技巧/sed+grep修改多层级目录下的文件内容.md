# sed+grep修改多层级目录下的文件内容

参考文章

1. [sed的递归问题](http://www.blogbus.com/kebe-jea-logs/59348026.html)

首先要明确, `sed`不能递归查询子目录进行查找匹配(`p`选项)与文件操作(`s`与`a`等选项). 如果待查找的目录下存在子目录, 会报错如下.

```
sed: read error on ./expect交互脚本: Is a directory
```

貌似`sed`并没有提供递归操作的支持, 所以需要寻找替换方案. `p`选项这样的查找匹配工作, 完全可以交给`grep`命令来做. `s`与`a`选项则必须先查找再进行对原文件的修改. sed需要拿到所有匹配条件的目标文件路径, 所以需要其他命令提供给它这个路径.

如果想要递归的替换某目录下所有文件的指定字符串, 需要先使用`grep`查找目录中符合条件的文件路径信息, 然后传递给`sed`. 要实现这个功能, 会用到`grep`的`-l`选项.

------

测试用的目录树结构如下

```
$ tree
.
├── aa.txt
└── bb
    └── bb.txt
```

我们希望将这个目录下所有文件中的'cc' 替换成 'hh.

`grep`命令查找的结果如下.

```
$ grep -ri 'cc' ./*
./aa.txt:ccc
./bb/bb.txt:cc
```

> 使用`grep`的`-l`参数可以单独输出文件路径而不再输出匹配行的内容.

```
$ grep -ril 'cc' ./*
./aa.txt
./bb/bb.txt
```

将`grep`查询到的结果作为`sed`的输入参数.

```
$ sed -i 's/cc/hh/g' $(grep -rl 'cc')
```

注意: `sed`命令中的被替换字符串要与`grep`查找的字符串相同, 都是'cc'

这样, `sed`可以递归地将用`grep`查到的包含'cc'行中的'cc'都替换成'hh'

> ps: 配合使用grep的`--include`选项会更加灵活
