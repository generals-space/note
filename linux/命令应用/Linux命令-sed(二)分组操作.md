# Linux命令-sed(二)分组操作

## 1. `&`引用全部

我们已经知道, `s`操作面向的不是匹配到目标字符串的整行, 而是匹配指定模式的字符串本身. 而`&`可以引用指定模式所匹配到的字符串(同一行内可能不只一处匹配到, 使用`s`操作的`g`标记会引用本行所有匹配到的字符).

```
$ cat file.txt
hello world
you hello
good work

## 在每个hello字符串后添加000
$ sed -ir 's/hello/&000/g' file.txt
$ cat file.txt
hello000 world
you hello000
good work

## 或者只在以hello开头的行的hello字符串后添加000
$ sed -ir 's/^hello/&000/g' file.txt
$ cat file.txt
hello000 world
you hello
good work
```

## 2. `(`与`)`自定义分组及引用

分组的创建使用`(`与`)`, 注意转义. `\1`到`\9`可引用匹配到的第1到第9个分组, 而上面讲到的`&`则可以看成所有分组的集合.

以如下文件为例

```
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0
```

在第1列的数字后加上000(比如时间单位弄错了, 秒需要替换成毫秒).

```
$ sed -ri 's/^([0-9]+)/\1000/g' file.txt
$ cat file.txt
199841605000 4 45151746 1 0
199841886000 6 109136864 16 0
199841950000 6 109132544 16 0
```

注意`s`操作第2段斜线中`\1`, 就是引用的前面`^([0-9]*)`的分组, 而且追加的内容与`\1`之间没有空格...这下知道为什么分组只能分到`\1`到`\9`了吧? 因为`\10`就表示在第1个分组后追加'0'了.

再比如

```
$ cat file.txt
199841605  4 45151746 1 0
199841886  6 109136864 16 0
199841950  6 109132544 16 0
199842374 6 109142594 16 0
```

第一列数据后有两个空格的行, 去除一个空格

```
$ sed -ri 's/^([0-9]+)(  )/\1 /' 目标文件名
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0
199842374 6 109142594 16 0
```

**注意**

上面所说分组方式有一个前提: `r`选项在`i`选项前面, 如果组合方式为`-ir`, 会出问题. 比如

```
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0
```

```
$ sed -ir 's/^([0-9]+)/\1000/g' file.txt
sed: -e expression #1, char 19: invalid reference \1 on `s' command's RHS
```

这种情况下可能需要把用作分组的'()'使用'\'进行转义, 另外'+'也不能使用, 分情况用'*'代替

```
$ sed -ir 's/^\([0-9]*\)/\1000/g' file.txt
$ cat file.txt
199841605000 4 45151746 1 0
199841886000 6 109136864 16 0
199841950000 6 109132544 16 0
```

然而, 使用`-sr`(`s`选项在`r`之前)进行替换预览却没有这个问题.

```
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0

$ sed -sr 's/^([0-9]+)/\1000/g' file.txt
199841605000 4 45151746 1 0
199841886000 6 109136864 16 0
199841950000 6 109132544 16 0
```

简直了...当前版本`sed (GNU sed) 4.2.2`, 这种情况简直匪夷所思.

## 3. 分组引用实例

### 3.1

有如下文件`test.txt`

```
i am A.
$$date=20110101
i am not B.
```

目标是将`$$date=20110101`这一行的`20110101`取出并赋值给某一变量, 可以使用如下命令

```
$ cat test.txt | sed -n 's/$$date=\([0-9]*\)/\1/p'
20110101
```

这一句组合使用了`s`与`p`操作...不明觉厉.
