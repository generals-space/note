# Nginx正则理解

Nginx中可以使用正则的指令, 目前我所知道的有: `location`, `if`, `rewrite`. 它们三者使用正则匹配的方式并不完全相同, 这里分别记录一下.

## 1. location与if的理解

`location`与`if`都可以看作是条件匹配然后执行某些操作的方式, 并且两者都可以通过正则匹配和字符串匹配. 只不过`location`匹配的只能是uri路径, 而if则可以匹配任何变量(不管是nginx内置变量还是自定义变量).

```
## if与括号()之间必须要有空格
if ($request_uri ^/main){
    set $abc 123;
}

location /main {
    set $abc 321;
}
```

------

我想两者的另一个最大的区别就是, `location`可以由nginx自身生成响应而`if`不行.

比如, `if`块中可以使用`rewrite`指令重定向让浏览器再发出一次http请求, 这一点与在`location`中相同; 

但是, `if`语句块中没有办法通过`root`指令指定本地的响应目录以返回哪怕是一个静态资源, 而且它也不能通过`proxy_pass`指令为客户端代理一个请求.

所以, 如果`if`语句在`location`之前完成了匹配并通过`rewrite`指令的, 就不会再执行`location`中的操作了.

## 1. Nginx匹配规则

### 1.1 location

- 没有任何符号 表示普通匹配, 可作为路径前缀匹配

- `=` 表示精确匹配, 其后面不能再接任何字符串

- `^~` 表示uri以某个常规字符串开头，不是正则匹配

- `~`|`!~` 表示区分大小写的正则匹配/不匹配

- `~*`|`!~*` 表示不区分大小写的正则匹配/不匹配

### 1.2 if

`if` 语句中必须出现至少一个符号, 它可以使用的匹配规则有:

- `=` | `!=` 表示精确匹配/不匹配, 可用于字符串/数值比较

- `~`|`!~` 表示区分大小写的正则匹配/不匹配

- `~*`|`!~*` 表示不区分大小写的正则匹配/不匹配

另外, nginx的`if`指令不存在`and`|`or`, `&&`|`||`等操作, 所以双重判断和嵌套判断还是有点难度的, 需要自己手动实现.

#### 1.2.1 实现if多重判断的方法

参考文章

[nginx中if判断实现多重判断](http://www.360doc.com/content/15/0119/14/15398874_442036739.shtml)

**第1种, 或方法实现**

判断用户来源IP, 如果是`123.123.123.0`, `123.123.124.0`, `123.123.125.0`三个网段的IP, 就返回502错误.

如果像下面这么写, 会出错的

```
if ($remote_addr ~* ^123\.123\.123\.[0-9]+ || $remote_addr ~* ^123\.123\.124\.[0-9]+ || $remote_addr ~* ^123\.123\.125\.[0-9]+ ) {
  return 502;
}
```

`nginx: [emerg] invalid condition "$remote_addr" in /usr/local/nginx/conf/nginx.conf:37`


参考写法是

```
set $flag 0;
if ($remote_addr ~* ^123\.123\.123\.[0-9]+){
    set $flag 1;
}
if ($remote_addr ~* ^123\.123\.124\.[0-9]+){
    set $flag 1;
}
if ($remote_addr ~* ^123\.123\.125\.[0-9]+){
    set $flag 1;
}
if ($flag = 1){
    return 502;
}
```

**第2种, 与方法实现**

参考写法

```
set $flag '';
if (条件1){
    set $flag '1';
}
if (条件2){
    set $flag "${flag}1";
}
if ($flag = '11'){
    操作...
}
```

## 2. 正则匹配模式

```
.     匹配除换行符以外的任意字符
\w     匹配字母或数字或下划线或汉字
\s     匹配任意的空白符
\d     匹配数字
\b     匹配单词的开始或结束
^     匹配字符串的开始
$     匹配字符串的结束

*     重复零次或更多次
+     重复一次或更多次
?     重复零次或一次
{n}     重复n次
{n,}     重复n次或更多次
{n,m}     重复n到m次
*?     重复任意次，但尽可能少重复
+?     重复1次或更多次，但尽可能少重复
??     重复0次或1次，但尽可能少重复
{n,m}?     重复n到m次，但尽可能少重复
{n,}?     重复n次以上，但尽可能少重复

\W     匹配任意不是字母，数字，下划线，汉字的字符
\S     匹配任意不是空白符的字符
\D     匹配任意非数字的字符
\B     匹配不是单词开头或结束的位置
[^x]     匹配除了x以外的任意字符
[^aeiou]     匹配除了aeiou这几个字母以外的任意字符

捕获     (exp)     匹配exp,并捕获文本到自动命名的组里
(?<name>exp)     匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp)     匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言     (?=exp)     匹配exp前面的位置
(?<=exp)     匹配exp后面的位置
(?!exp)     匹配后面跟的不是exp的位置
(?<!exp)     匹配前面不是exp的位置
注释     (?#comment)     这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
```

## 3. 场景1

要在指定`location`块中只允许`115.238.91.226`与`183.136.223.162`两个来源的用户访问, 如何实现?

**错误示例1**

```
location /prefix{
    if ($remote_addr != 115.238.91.226) {
        return 404;
    }
    if ($remote_addr != 183.136.223.162) {
        return 404;
    }
    proxy_pass http://upstream;
}
```

**错误示例2**

```
location /prefix{
    if ($remote_addr !~ 183\.136\.223\.162) {
        return 404;
    }
    if ($remote_addr !~ 183\.136\.223\.162) {
        return 404;
    }
    proxy_pass http://upstream;
}
```

这两种都没有起到应有的作用...无论以什么IP来访, 都会得到404...可能`或`条件不是么写的.

除了正经的`或`方法, 其实也可以用正则直接匹配多个嘛.

```
location /prefix{
    if ($remote_addr !~ (183\.136\.223\.162)|(115\.238\.91\.226)) {
        return 404;
    }
    proxy_pass http://upstream;
}
```

完成