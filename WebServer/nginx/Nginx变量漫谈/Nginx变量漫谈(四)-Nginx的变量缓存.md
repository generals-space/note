# Nginx变量漫谈(四)-Nginx的变量缓存

## 4.1 取处理程序

### 4.1.1 可改写的内建变量

有一些内建变量是支持改写的, 其中一个例子是`$args`. 这个变量在读取时返回当前请求的URL参数串(即请求URL中问号后面的部分, 如果有的话), 而在赋值时可以直接修改参数串. 我们来看一个例子:

```
location /test {
    set $orig_args $args;
    set $args "a=3&b=4";

    echo "original args: $orig_args";
    echo "args: $args";
}
```

这里我们把原始的URL参数串先保存在`$orig_args`变量中, 然后通过改写`$args`变量来修改当前的URL参数串, 最后我们用echo指令分别输出`$orig_args`和`$args`变量的值. 接下来我们这样来测试这个`/test`接口:

```
$ curl 'http://localhost:8080/test'
original args: 
args: a=3&b=4

$ curl 'http://localhost:8080/test?a=0&b=1&c=2'
original args: a=0&b=1&c=2
args: a=3&b=4
```

在第一次测试中, 我们没有设置任何URL参数串, 所以输出$orig_args变量的值时便得到空. 而在第一次和第二次测试中, 无论我们是否提供URL参数串, 参数串都会在location /test中被强行改写成a=3&b=4.

需要特别指出的是, **这里的`$args`变量和`$arg_XXX`一样, 也不再使用属于自己的存放值的容器**. 当我们读取`$args`时, Nginx会执行一小段代码，从Nginx核心中专门存放当前URL参数串的位置去读取数据; 而当我们改写`$args`时, Nginx 会执行另一小段代码, 对相同位置进行改写. Nginx的其他部分在需要当前URL参数串的时候, 都会从那个位置去读数据, 所以我们对`$args`的修改会影响到所有部分的功能.

来看一个例子:

```
location /test {
    set $orig_a $arg_a;
    set $args "a=5";
    echo "original a: $orig_a";
    echo "a: $arg_a";
}
```

这里我们先把内建变量`$arg_a`的值, 即原始请求的URL参数a的值, 保存在用户变量$orig_a中, 然后通过对内建变量`$args`进行赋值, 把当前请求的参数串改写为a=5, 最后再用echo指令分别输出`$orig_a`和`$arg_a`变量的值. 因为对内建变量$args的修改会直接导致当前请求的URL参数串发生变化, 因此内建变量`$arg_XXX`自然也会随之变化.

测试的结果证实了这一点:

```
$ curl 'http://localhost:8080/test?a=3'
original a: 3
a: 5
```

我们看到, 因为原始请求的URL参数串是a=3, 所以$arg_a最初的值为3, 但随后通过改写$args变量, 将URL参数串又强行修改为a=5, 所以最终`$arg_a`的值又自动变为了5.

再来看一个通过修改`$args`变量影响标准的HTTP代理模块`ngx_proxy`的例子:

```
server {
    listen 8080;

    location /test {
        set $args "foo=1&bar=2";
        proxy_pass http://127.0.0.1:8081/args;
    }
}

server {
    listen 8081;

    location /args {
        echo "args: $args";
    }
}
```

这里我们在http配置块中定义了两个虚拟主机. 第一个虚拟主机监听8080端口, 其`/test`接口自己通过改写`$args`变量, 将当前请求的URL参数串无条件地修改为`foo=1&bar=2`. 然后`/test`接口再通过ngx_proxy模块的`proxy_pass`指令配置了一个反向代理, 指向本机的8081端口上的HTTP服务`/args`. **默认情况下ngx_proxy模块在转发HTTP请求到远方HTTP服务的时候, 会自动把当前请求的URL参数串也转发到远方**.

而本机的8081端口上的HTTP服务正是由我们定义的第二个虚拟主机来提供的. 我们在第二个虚拟主机的`location /args`中利用echo指令输出当前请求的URL参数串, 以检查`/test`接口通过ngx_proxy模块实际转发过来的URL请求参数串.

我们来实际访问一下第一个虚拟主机的`/test`接口:

```
$ curl 'http://localhost:8080/test?blah=7'
args: foo=1&bar=2
```

我们看到, 虽然请求自己提供了URL参数串`blah=7`, 但在`location /test`中, 参数串被强行改写成了`foo=1&bar=2`. 接着经由`proxy_pass`指令将我们**被改写掉的参数串**转发给了第二个虚拟主机上配置的`/args`接口, 然后再把`/args`接口的URL参数串输出. 事实证明, 我们对`$args`变量的赋值操作, 也成功影响到了ngx_proxy模块的行为.

### 4.1.2 取处理程序

上面提到的, 在读取变量时执行的这段特殊代码, 在Nginx中被称为`取处理程序`(get handler); 而改写变量时执行的这段特殊代码, 则被称为`存处理程序`(set handler). 不同的Nginx模块一般会为它们的变量准备不同的"存取处理程序", 从而让这些变量的行为充满魔法.

其实这种技巧在计算世界并不鲜见. 比如在面向对象编程中, 类的设计者一般不会把类的成员变量直接暴露给类的用户, 而是另行提供两个方法(method), 分别用于该成员变量的读操作和写操作, 这两个方法常常被称为`存取器`(accessor). 下面是C++语言中的一个例子:

```c++
#include <string>
using namespace std;

class Person {
public:
    const string get_name() {
        return m_name;
    }

    void set_name(const string name) {
        m_name = name;
    }

private:
    string m_name;
};
```

在这个名叫Person的C++类中, 我们提供了`get_name`和`set_name`这两个公共方法, 以作为私有成员变量`m_name`的`存取器`.

这样设计的好处是显而易见的. 类的设计者可以在"存取器"中执行任意代码, 以实现所需的业务逻辑以及"副作用", 比如自动更新与当前成员变量存在依赖关系的其他成员变量, 抑或是直接修改某个与当前对象相关联的数据库表中的对应字段. 而对于后一种情况, 也许"存取器"所对应的成员变量压根就不存在, 或者即使存在, 也顶多扮演着数据缓存的角色, 以缓解被代理数据库的访问压力.

与面向对象编程中的"存取器"概念相对应, Nginx变量也是支持绑定"存取处理程序"的. Nginx模块在创建变量时, 可以选择是否为变量分配存放值的容器, 以及是否自己提供与读写操作相对应的"存取处理程序".

不是所有的Nginx变量都拥有存放值的容器. 拥有值容器的变量在Nginx核心中被称为"被索引的"(indexed); 反之, 则被称为"未索引的"(non-indexed).

我们前面在已经知道, 像`$arg_XXX`这样具有无数变种的变量群, 是"未索引的". **当读取这样的变量时, 其实是它的"取处理程序"在起作用, 即实时扫描当前请求的URL参数串, 提取出变量名所指定的URL参数的值**.

很多新手都会对`$arg_XXX`的实现方式产生误解, 以为Nginx会事先解析好当前请求的所有URL参数并且把相关的`$arg_XXX`变量的值都事先设置好. 然而事实并非如此. Nginx根本不会事先就解析好URL参数串, 而是在用户读取某个`$arg_XXX`变量时, 调用其"取处理程序", 即时去扫描URL参数串. 类似地, 内建变量`$cookie_XXX`也是通过它的"取处理程序", 即时去扫描Cookie请求头中的相关定义的.

## 4.2 变量缓存与惰性求值

在设置了"取处理程序"的情况下, Nginx变量也可以选择将其值容器用作缓存, 这样在多次读取变量的时候, 就只需要调用"取处理程序"计算一次. 我们下面就来看一个这样的例子:

```
map $args $foo {
    default     0;
    debug       1;
}

server {
    listen 8080;

    location /test {
        set $orig_foo $foo;
        set $args debug;

        echo "orginal foo: $orig_foo";
        echo "foo: $foo";
    }
}
```

这里首次用到了标准ngx_map模块的map配置指令, 我们有必要在此介绍一下. map在英文中除了"地图"之外, 也有"映射"的意思. 比方说, 中学数学里讲的"函数"就是一种"映射". 而Nginx的这个map指令就可以用于定义两个Nginx变量之间的映射关系, 或者说是函数关系.

回到上面这个例子, 我们用map指令定义了用户变量`$foo`与`$args`内建变量之间的映射关系. 特别地, 用数学上的函数记法`y = f(x)`来说, 我们的$args就是"自变量"x, 而`$foo`则是"因变量"y, 即$foo的值是由$args的值来决定的, 或者按照书写顺序可以说, 我们将`$args`变量的值映射到了$foo变量上.

现在我们再来看map指令定义的映射规则:

```
map $args $foo {
    default     0;
    debug       1;
}
```

花括号中第一行的default是一个特殊的匹配条件, 即当其他条件都不匹配的时候, 这个条件才匹配. 当这个默认条件匹配时, 就把"因变量"$foo映射到值0. 而花括号中第二行的意思是说, 如果"自变量"$args精确匹配了debug这个字符串, 则把"因变量"$foo映射到值1. 将这两行合起来, 我们就得到如下完整的映射规则: 当$args的值等于debug的时候, $foo变量的值就是 1, 否则$foo的值就为0.

明白了map指令的含义, 再来看location/test. 在那里, 我们先把当前$foo变量的值保存在另一个用户变量$orig_foo中, 然后再强行把$args的值改写为debug, 最后我们再用echo指令分别输出$orig_foo和$foo的值.

从逻辑上看, 似乎当我们强行改写$args的值为debug之后, 根据先前的map映射规则, $foo变量此时的值应当自动调整为字符串1, 而不论$foo原先的值是怎样的. 然而测试结果并非如此:

```
$ curl 'http://localhost:8080/test'
original foo: 0
foo: 0
```

第一行输出指示$orig_foo的值为0, 这正是我们期望的: 上面这个请求并没有提供URL参数串, 于是$args最初的取值就是空, 再根据我们先前定义的映射规则, $foo变量在第一次被读取时的值就应当是0(即匹配默认的那个default条件).

而第二行输出显示, 在强行改写$args变量的值为字符串debug之后, $foo的条件仍然是0, 这显然不符合映射规则. 因为当$args为debug时, $foo的值应当是1. 这究竟是为什么呢?

其实原因很简单, 那就是$foo变量在第一次读取时, 根据映射规则计算出的值被缓存住了. 刚才我们说过, Nginx模块可以为其创建的变量选择使用值容器, 作为其"取处理程序"计算结果的缓存. 显然, ngx_map模块认为变量间的映射计算足够昂贵, 需要自动将因变量的计算结果缓存下来, 这样在当前请求的处理过程中如果再次读取这个因变量, Nginx就可以直接返回缓存住的结果, 而不再调用该变量的"取处理程序"再行计算了.

为了进一步验证这一点, 我们不妨在请求中直接指定URL参数串为debug:

```
$ curl 'http://localhost:8080/test?debug'
original foo: 1
foo: 1
```

我们看到, 现在$orig_foo的值就成了1. 因为变量$foo在第一次被读取时, 自变量$args的值就是debug, 于是按照映射规则, "取处理程序"计算返回的值便是1. 而后续再读取$foo的值时, 就总是得到被缓存住的1这个结果, 而不论$args后来变成什么样了.

**注解: 这种情况应该是map模块在set与echo模块之前执行而发生, 这涉及到Nginx的内部执行过程.**

map指令其实是一个比较特殊的例子, 因为它可以为用户变量注册"取处理程序", 而且用户可以自己定义这个"取处理程序"的计算规则. 当然, 此规则在这里被限定为与另一个变量的映射关系. 同时, 也并非所有使用了"取处理程序"的变量都会缓存结果, 例如我们前面在(三)中已经看到$arg_XXX并不会使用值容器进行缓存.

类似ngx_map模块, 标准的ngx_geo等模块也一样使用了变量值的缓存机制.

在上面的例子中, 我们还应当注意到map指令是在server配置块之外, 也就是在最外围的http配置块中定义的. 很多读者可能会对此感到奇怪, 毕竟我们只是在location /test中用到了它. 这倒不是因为我们不想把map语句直接挪到location配置块中, 而是因为map指令只能在http块中使用!

很多Nginx新手都会担心如此"全局"范围的map设置会让访问所有虚拟主机的所有location接口的请求都执行一遍变量值的映射计算, 然而事实并非如此. 前面我们已经了解到map配置指令的工作原理是为用户变量注册"取处理程序", 并且实际的映射计算是在"取处理程序"中完成的, 而"取处理程序"只有在该用户变量被实际读取时才会执行(当然, 因为缓存的存在, 只在请求生命期中的第一次读取中才被执行), 所以对于那些根本没有用到相关变量的请求来说, 就根本不会执行任何的无用计算.

这种只在实际使用对象时才计算对象值的技术, 在计算领域被称为"惰性求值"(lazy evaluation). 提供"惰性求值"语义的编程语言并不多见, 最经典的例子便是Haskell. 与之相对的便是"主动求值"(eager evaluation). 我们有幸在Nginx中也看到了"惰性求值"的例子, 但"主动求值"语义其实在Nginx里面更为常见, 例如下面这行再普通不过的set语句:
set $b "$a,$a";

这里会在执行set规定的赋值操作时, "主动"地计算出变量$b的值, 而不会将该求值计算延缓到变量$b实际被读取的时候.