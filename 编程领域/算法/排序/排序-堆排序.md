
堆排序仍然是in-place排序, 所以虽然说是借助了二叉树结构(完全二叉树而不是平衡二叉树), 但树本身其实是不存在的.

另外, 完全二叉树还不如平衡二叉树有序呢, 但是后者的前中后序遍历没有一个是按照大小输出的, 所以堆排序的构造过程和遍历输出过程都同样重要.

```js
/**
 * 参考文章
 * 1. [白话讲排序系列（六） 堆排序（绝对让你明白堆排序！）](https://blog.csdn.net/u013384984/article/details/79496052)
 * */
var arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47];
// var arr = [4, 6, 8, 5, 9];

console.log(arr);
arr = heapSort(arr);
console.log(arr);

function heapSort(arr) {
    // 每一个无序数组, 都可以看成是一个完全二叉树. 
    // 注意这个说法, 因为完全二叉树只与树节点排布有关, 而与节点数值的大小无关.
    // 只要把数组想像成树的形象就行了.
    let len = arr.length;

    // 将一个无序的完全二叉树转换成大顶堆, 流程图示可以见参考文章1.
    // 大顶堆首先是一个完全二叉树, 还有一个条件是, 是对于任意一个子节点来说, 均不大于其父节点的值. 
    // 这样, 根节点为所有节点中数值最大的节点.
    // 简单来说就是要将所有拥有子节点的节点都变成最大的. 所以目标就是同时拥有两个子节点的节点.
    // 所有操作要从树中最后一个非叶子节点开始, 最后一个非叶子节点可以通过`len/2-1`得到.
    // 注意: 虽然遍历通过i--循环, 可能循环到没有子节点或是只有单个子节点的节点, 
    // 但是在heapify()函数中, 会计算left_child/right_child节点索引, 如果不是拥有两个子节点,
    // 那么left_child/right_child会大于len, swap计算仍然会成功.
    for (let i = Math.floor(len/2); i >= 0; i--) {
        heapify(arr, i, len);
    }
    
    // 大顶堆建立完成, 之后的步骤是将大顶堆的根节点(就是整个数组中最大的节点)排到数组末尾.
    // 然后调整堆, 再次形成标准的大顶堆, 就这样依次将最大的数值放到数组末尾, 最后就可完成排序.
    for (let i = arr.length - 1; i > 0; i--) {
        swap(arr, 0, i);
        len--;
        // 交换根节点与末尾节点的成员.
        // 注意, 此时len是依次递减的.
        heapify(arr, 0, len);
    }
    return arr;
}

// i是树中拥有子节点的节点(非叶子节点)...的索引.
// ...也不一定, 其实按照参考文章中的示意图, 每次堆调整操作的目标i都应该是拥有子节点的节点,
// 但是在主调函数中, 由于i的值是在for循环中通过减1操作完成的, 所以难免会循环到叶子节点上.
function heapify(arr, i, len) {
    let left_child = 2 * i + 1; // i节点的左侧子节点
    let right_child = left_child + 1; // i节点的右侧子节点
    let parent = i; 

    // 得到3个节点中最大的节点, 如果i节点没有右侧子节点, 
    if (left_child < len && arr[left_child] > arr[parent]) parent = left_child;
    if (right_child < len && arr[right_child] > arr[parent]) parent = right_child;

    // 结束标识
    if (parent != i) {
        // 交换i节点与3者中最大的节点的位置
        swap(arr, i, parent);
        // 交换后可能造成新的左/右子树下不满足大顶堆的要求, 所以递归调用直到可以完全满足.
        heapify(arr, parent, len);
    }
}

function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

```

```py
import math

arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47]

def heap_sort(arr):
    length = len(arr)
    ## 建立大顶堆
    for i in range(math.floor(length/2), -1, -1):
        heapify(arr, i, length)

    ## 将大顶堆根节点放到数组末尾, 然后调整树结构, 使之重新成为大顶堆, 重复这个过程
    for i in range(length - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        length -= 1
        heapify(arr, 0, length)
    return arr

def heapify(arr, i, length):
    parent = i
    left_child = i * 2 + 1
    right_child = left_child + 1

    if left_child < length and arr[left_child] > arr[parent]: parent = left_child
    if right_child < length and arr[right_child] > arr[parent]: parent = right_child

    if parent != i:
        arr[i], arr[parent] = arr[parent], arr[i]
        heapify(arr, parent, length)

print(arr)
arr = heap_sort(arr)
print(arr)

```