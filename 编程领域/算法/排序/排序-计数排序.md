
计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。(参考文章1)

优化方式: 参考文章1中实现了一个`findArrMaxMin()`函数, 事先查找目标数组中的最大值及最小值, 之后再调用计数排序函数, 节省了两侧不必要的内存空间.

```js
var arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47];

console.log(arr);
arr = countingSort(arr, 50);
console.log(arr);

// 使用计数排序需要先知道数组中的最大值.
function countingSort(arr, maxValue) {
    let bucket = new Array(maxValue + 1);
    let sortedIndex = 0;
    let bucketLen = maxValue + 1;

    // 统计数组成员, 并入桶
    for (let i = 0; i < arr.length; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }
    // 遍历桶内数据
    for (let j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex] = j;
            bucket[j]--;
            sortedIndex++;
        }
    }

    return arr;
}
```

```py
arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47]

def count_sort(arr, maxValue):
    ## 初始化定长数组(空列表无法满足入桶需求)
    ## js中初始化定长数组时每个成员初始值为undefined
    ## python里没有类似的方法, 且为了防止数组中存在0值成员, 
    ## 这里将初始值都设置为空字符串.
    bucket = ['' for i in range(0, maxValue+1)]

    for i in range(0, len(arr)):
        val = arr[i]
        if bucket[val] == '': bucket[val] = 0
        bucket[val] += 1

    arrIndex = 0
    for i in range(0, maxValue+1):
        if bucket[i] == '': continue
        while True:
            if bucket[i] <= 0: break

            arr[arrIndex] = i
            bucket[i] -= 1
            arrIndex +=1
    return arr

print(arr)
arr = count_sort(arr, 50)
print(arr)

```