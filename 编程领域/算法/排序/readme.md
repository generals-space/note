参考文章

1. [各种排序算法总结和比较](https://www.cnblogs.com/zhaoshuai1215/p/3448154.html)
    - C语言示例
2. [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)
    - 动图展示
    - Js示例
3. [排序算法总结](https://www.runoob.com/w3cnote/sort-algorithm-summary.html)
    - 各种算法总结与注意点, 适用场景以及优化方案
    - 各种辅助理解的场景让人印象深刻
    - Java示例
4. [十大经典排序算法动画与解析，看我就够了！（配代码完全版）](https://github.com/MisterBooo/Article)
    - 各排序方法的in-place/out-place信息
    - 动图展示
    - Java示例
5. [白话讲排序系列（六） 堆排序（绝对让你明白堆排序！）](https://blog.csdn.net/u013384984/article/details/79496052)
    - 完全二叉树, 大顶堆, 小顶堆概念
    - 堆排序操作流程(比以上参考文章都更详细)
6. [1.9 桶排序](https://www.runoob.com/w3cnote/bucket-sort.html)
    - 虽然与参考文章1, 2, 4相比并不十分详尽, 但点出了桶排序的几个要点.

衡量排序算法效率的指标一般有如下3种:

1. 稳定性: 有两个(或多个)元素相等, 排序完成后这些元素的顺序不变的, 称为"稳定", 反之称为"不稳定";
2. 时间复杂度: 按照最好/最差以及平均的消耗时间, 这个值一共有3个;
3. 空间复杂度: 按照排序算法`in-place`/`out-place`的不同, 某些算法需要在原乱序序列重新开辟一个等长的序列来存储有序序列, 或是需要借助"树"这种数据结构辅助排序. 这些操作占用了额外的内存, 在数据量较大的情况下不可忽略, 空间复杂度用来计算内存消耗情况.

很多语言没有指针, 是如何实现in-place排序的? 


除了在学校里学过的冒泡排序, 一般人最先想到的排序方式应该就是选择排序(遍历数组, 找到最小的放到最前面, 然后依次重复)了.

注意: 非比较型排序算法应该不利于负数的排序...
