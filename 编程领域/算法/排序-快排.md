
## 快排

快排如何挑选作为基准的成员的索引?
与基准成员比较后的前移和后移操作如何完成? 通过append或insert吗(不会改变数组本身迭代器吗)? 如果在C语言中(数组空间固定)如何操作呢?

```py
arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47]

def quick_sort(arr, left, right):
    ## 结束条件: 当前分组只有1个成员时.
    ## 注意: arr一直是最初的arr, 因为传递的是引用值, "分组"操作只是在指定左右区间的索引而已
    if left >= right: return arr

    partitionIndex = partition(arr, left, right)
    quick_sort(arr, left, partitionIndex - 1)
    quick_sort(arr, partitionIndex + 1, right)
    return arr

def partition(arr, left, right):
    '''
    @function: 以索引为0处的成员作为基准值, 将比基准小的成员移动到基准值左侧.
    注意: 此时right一定大于left(在主调函数中验证过)
    @return: 返回新数组中基准成员的索引.
    '''
    ## 把每个分组的第一个成员当作基准
    pivot = left
    pivot_val = arr[pivot]
    smaller_list_right = pivot
    cursor = pivot
    while True:
        if cursor >= right: break
        cursor+=1

        ## 如果当前成员大于基准值, 则无操作, smaller_list_right值不变
        if pivot_val < arr[cursor]: continue
        ## 如果当前成员小于基准值, 则将当前成员交换到smaller_list_right处
        smaller_list_right+=1
        arr[cursor], arr[smaller_list_right] = arr[smaller_list_right], arr[cursor]
    ## while循环结束后, 从第2个成员开始会有一组比基准值小的成员smaller_list, 之后是比基准值大的成员
    print(arr) ## 第一次 [5, 3, 2, 4, 44, 38, 36, 26, 50, 27, 15, 46, 48, 19, 47]
    
    ## 这里再将基准成员与small_list最右边的成员(smaller_list_right处)交换位置, 这样比基准值少的成员就全部到了基准成员左侧.
    arr[pivot], arr[smaller_list_right] = arr[smaller_list_right], arr[pivot]
    print(arr) ## 第一次 [4, 3, 2, 5, 44, 38, 36, 26, 50, 27, 15, 46, 48, 19, 47]
    return smaller_list_right

print(arr)
arr = quick_sort(arr, 0, len(arr) - 1)
print(arr)

```

```js
var arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47];

console.log(arr);
arr = quickSort(arr, 0, arr.length - 1);
console.log(arr);

function quickSort(arr, left, right) {
    // 结束条件: 当前分组只有1个成员时.
    // 注意: arr一直是最初的arr, 因为传递的是引用值, "分组"操作只是在指定左右区间的索引而已
    if (left >= right) return arr;

    let partitionIndex = partition(arr, left, right);
    quickSort(arr, left, partitionIndex - 1);
    quickSort(arr, partitionIndex + 1, right);
    return arr;
}

// @function: 以索引为0处的成员作为基准值, 将比基准小的成员移动到基准值左侧.
// 注意: 此时right一定大于left(在主调函数中验证过)
// @return: 返回新数组中基准成员的索引.
function partition(arr, left, right) {
    // 把每个分组的第一个成员当作基准
    let pivot = left;
    let pivot_val = arr[pivot];
    let smaller_list_right = pivot;

    // 这里采用的策略是, 先将小于基准的成员移动到靠近基准的右侧部分
    for (let cursor = pivot + 1; cursor <= right; cursor ++) {
        // 如果当前成员大于基准值, 则无操作, smaller_list_right值不变
        if (pivot_val <= arr[cursor]) continue;
        // 如果当前成员小于基准值, 则将当前成员交换到smaller_list_right处
        smaller_list_right++;
        swap(arr, cursor, smaller_list_right);
    } 
    // 第一次smaller_list_right为4, i为15, 
    // 可以说i表示从索引为0的基准开始向右遍历所经历成员的数量, 
    // smaller_list_right为比基准值小的成员数量
    console.log(arr); // 第一次 [ 5, 3, 2, 4, 44, 38, 36, 26, 50, 27, 15, 46, 48, 19, 47 ]

    // 然后这里将基准成员与最右侧最小的成员交换位置, 这样就相当于将小于基准值的成员移到了左侧, 
    // 但是采用的不是append/insert操作, 不改变原来的数组空间
    swap(arr, pivot, smaller_list_right);
    console.log(arr); // 第一次 [ 4, 3, 2, 5, 44, 38, 36, 26, 50, 27, 15, 46, 48, 19, 47 ]
    return smaller_list_right; // 这里得到本次移动后基准成员的索引, 值为3
}

// 交换两处的数据
function swap(arr, x, y) {
    let temp = arr[x];
    arr[x] = arr[y];
    arr[y] = temp;
}

```