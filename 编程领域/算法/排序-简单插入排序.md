A: 当选择一个元素与已经排过序的部分进行比较时, 插入到合适的位置需要批量移动元素, 如何实现?
Q: 从后向前依次比较, 如果前面的有序数值大于当前成员值, 则将此有序数值向后移动, 直到找到小于当前成员值的成员, 将当前成员插入.

```py
arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47]

def insert_sort(arr):
    for i in range(1, len(arr)):
        ## 以第一个元素为已排序过的元素, 遍历之后的元素向前/向后插入.
        current = arr[i]
        preIndex = i - 1
        ## 遍历已排过序的部分(从后往前), 
        ## 一边遍历, 一边将比current大的成员向后移动, 
        ## 但不必遍历全部, 找到比当前索引i处数值current更小的成员即可插入.
        while preIndex >= 0 and arr[preIndex] > current:
            arr[preIndex + 1] = arr[preIndex]
            preIndex -= 1
        ## 这里比较容易出错, 注意加1
        arr[preIndex + 1] = current
    return arr

print(arr)
arr = insert_sort(arr)
print(arr)

```

```js
var arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47];

console.log(arr);
arr = insertionSort(arr);
console.log(arr);

function insertionSort(arr) {
    // 以第一个元素为已排序过的元素, 遍历之后的元素向前/向后插入.
    for (var i = 1; i < arr.length; i++) {
        let preIndex = i - 1;
        let current = arr[i];
        // 遍历已排过序的部分(从后往前), 
        // 一边遍历, 一边将比current大的成员向后移动, 
        // 但不必遍历全部, 找到比当前索引i处数值current更小的成员即可插入.
        while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        // 这里比较容易出错, 注意加1
        arr[preIndex + 1] = current;
    }
    return arr;
}

```