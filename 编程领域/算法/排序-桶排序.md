参考文章1, 2, 4中都描述了桶排序, 云里雾里的. 

感觉就是将待排序数组分割成几个子数组, 对ta们分别排序. 

对子数组排序的方法又不是固定的, 可以根据实际情况选择. 

各子数组排完序后将各自的结果组合到一起, 就是最终结果.

...这也太草率了, 可以说桶排序没有具体的实现算法和流程, ta只是提供了一个大致的思路而已, 与其他算法有很大的区别. 还不如希尔排序对简单插入排序的改进明确呢.

参考文章6点出了桶排序的几个要点, 也给出了容易理解的示意图. 可以看一下.

我疑惑的是, 映射函数如何编写? 所有的示例中映射函数都基本相同, 就是按照待排序数组中最大值与最小值的差值.

```js
// var arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47];
var arr = [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];

console.log(arr);
arr = bucketSort(arr);
console.log(arr);

function bucketSort(arr) {
    let minValue = arr[0];
    let maxValue = arr[0];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < minValue) {
            minValue = arr[i];                // 输入数据的最小值
        } else if (arr[i] > maxValue) {
            maxValue = arr[i];                // 输入数据的最大值
        }
    }

    ///////////////////////////////////// 桶的初始化
    // 桶的容量为5. 
    // 注意, 这里的容量不表示桶中可容纳的成员数量, 而是表是桶中成员差值的最大值.
    // 如bucketSize = 5时, 桶中可容纳[1,1,1,1,1,1,1,1,2,3,4,5]等.
    // 原因在于得到bucketCount所使用的方法.
    let bucketSize = 5; 
    let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // 得到桶数量
    let buckets = new Array(bucketCount);
    for (let i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }

    // 利用映射函数将数据分配到各个桶中
    for (let i = 0; i < arr.length; i++) {
        // 注意, 这里将数组中的每个成员都与最小成员求差值, 以保证各桶中成员值是依次递增的.
        // 这样当各桶中成员排序完成后, 组合各桶结果时直接拼接即可, 不需要再进行额外排序.
        let key = Math.floor((arr[i] - minValue) / bucketSize);
        buckets[key].push(arr[i]);
    }
    console.log(buckets);
    arr = [];
    // 对每个桶中的数据进行排序，这里使用了插入排序
    for (let i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);
        for (let j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);
        }
    }

    return arr;
}

function insertionSort(arr) {
    // 以第一个元素为已排序过的元素, 遍历之后的元素向前/向后插入.
    for (let i = 1; i < arr.length; i++) {
        let preIndex = i - 1;
        let current = arr[i];
        // 遍历已排过序的部分(从后往前), 
        // 一边遍历, 一边将比current大的成员向后移动, 
        // 但不必遍历全部, 找到比当前索引i处数值current更小的成员即可插入.
        while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        // 这里比较容易出错, 注意加1
        arr[preIndex + 1] = current;
    }
    return arr;
}

```

```py
import math

arr = [5, 38, 15, 48, 44, 3, 36, 26, 50, 27, 2, 46, 4, 19, 47]

def bucket_sort(arr):
    ## 得到待排序数组中成员的最大值和最小值, 以此确定桶数量
    minVal, maxVal = min(arr), max(arr)

    bucketSize = 5
    bucketCount = math.floor((maxVal - minVal) / bucketSize) + 1
    buckets = [[] for i in range(0, bucketCount)]

    ## 使用映射函数将待排序数组中的所有成员填充到不同的桶中.
    for i in range(0, len(arr)):
        key = math.floor((arr[i] - minVal) / bucketSize)
        buckets[key].append(arr[i])
    
    ## 对各桶分别进行排序, 然后将结果合并
    arr = []
    for i in range(0, len(buckets)):
        insert_sort(buckets[i])
        arr.extend(buckets[i])

    return arr

def insert_sort(arr):
    for i in range(1, len(arr)):
        ## 以第一个元素为已排序过的元素, 遍历之后的元素向前/向后插入.
        current = arr[i]
        preIndex = i - 1
        ## 遍历已排过序的部分(从后往前), 
        ## 一边遍历, 一边将比current大的成员向后移动, 
        ## 但不必遍历全部, 找到比当前索引i处数值current更小的成员即可插入.
        while preIndex >= 0 and arr[preIndex] > current:
            arr[preIndex + 1] = arr[preIndex]
            preIndex -= 1
        ## 这里比较容易出错, 注意加1
        arr[preIndex + 1] = current
    return arr

print(arr)
arr = bucket_sort(arr)
print(arr)

```