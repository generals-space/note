参考文章

1. [二叉查找树与平衡二叉树](https://blog.csdn.net/qq_25940921/article/details/82183093)
    - 文末介绍了平衡二叉树的缺点, 由此引出红黑树.

2. [红黑树 - 维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
    - 解释了`nil`节点在图示中的作用

3. [红黑树（附完整C代码）](https://blog.csdn.net/weewqrer/article/details/51866488)
    - 红黑树 VS AVL树, 讲解了红黑树的优势.

[红黑树从头至尾插入和删除结点的全程演示图](https://blog.csdn.net/v_july_v/article/details/6284050)
    - 一个20节点的红黑树的构建过程, 图示十分详细, 涉及到5种旋转.


由于平衡二叉树在构建过程中, 时刻保持平衡特性, 所以一旦插入新节点导致失衡需要调整, 最多也只要旋转2次. 

但是删除节点时有可能因为失衡, 导致需要从删除节点的父节点开始, 不断的回溯到根节点, 如果这棵平衡二叉树很高的话, 那中间就要判断很多个节点. 

所以后来也出现了综合性能比其更好的树—-红黑树. 

## 

本来以为红黑树是一种特殊的平衡二叉树, 还在疑问为什么所有文章在讲解红黑树时都以二叉查找树做引述...

红黑树并不是平衡二叉树, ta没有左右子树高度差<=1的限制. 如下就是一种红黑树, 但左右子树高度已经相差为2了.

```

```

## 特性

红黑树的平衡有两个维度: 一个是满足平衡二叉树的所有特点, 另一个是颜色的额外限制. 如果有一个条件不满足, 就不能说该树平衡.

红黑树总是保持黑色节点的完美平衡.

最长的路径不会超过最短路径的两倍?

是否可以认为普通平衡二叉树的所有节点都是黑色的?

红黑树确保没有一条路径会比其他路径长出2倍...但是AVL好像也不会啊?

红黑树的其他优势:

1. 插入节点的复杂度与AVL相似, 但是删除时最多旋转3次, 比AVL简单
2. 插入/删除节点时AVL更容易失衡调整, 总体来说红黑树更稳定.

## 关于nil节点

> 在很多树数据结构的表示中, 一个节点有可能只有一个子节点, 而叶子节点包含数据. 用这种范例表示红黑树是可能的, 但是这会改变一些性质并使算法复杂. 为此, 本文中我们使用"nil叶子"或"空（null）叶子", 如上图所示, 它不包含数据而只充当树在此结束的指示. 这些节点在绘图中经常被省略, 导致了这些树好像同上述原则相矛盾, 而实际上不是这样. 与此有关的结论是**所有节点都有两个子节点**, 尽管其中的一个或两个可能是空叶子. --选自参考文章2.

网上许多文章中的红黑树图示中都包含**值为`nil`的黑色叶子节点**, 这种`nil`节点当作树的结尾, 不再拥有子节点. 这些结点的存在实际上是为了满足红黑树的5个特性, 如果图中不画出这些结点, 可能会导致这些树不符合红黑树的条件, 感觉类似于做减法中的**借位**操作.

再形象点, 去超市买东西, 你需要付7元, 你会付10元, 然后收银员找回3元. 很多时候收银员会问你再要2元, 然后他找你5元(超市零钱消耗得很快, 所以这种数学题还是有应用场景的...移动支付普及前). 

这2元不会造成任何不好的后果, 但是会让双方都更方便. 这就是`nil`黑色叶子节点的作用.

...我觉得我真是太厉害了.

需要注意的是, 在程序中的确存在`nil`节点, C语言中会声明一个`*Node`指针但并不为你开辟空间与赋值???

## 旋转

在构造红黑树的过程中, 由于失衡可能会进行3种操作: 左旋, 右旋, 变色...当然大部分网卡的文章都是这么介绍的, 实际上左旋/右旋包含了平衡二叉树中的LL, RR, LR, RL四种旋转方式. 而且以变色为优先手段, 即当发现不满足红黑树的平衡条件时先尝试改变上层节点颜色, 如果追溯到根节点都无法解决, 就需要借助旋转操作了.

在所有的插入示例中都会提到一种红黑树的形态, 实在是太典型了. 如下

```

```

