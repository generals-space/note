参考文章

1. [【数据结构】红黑树插入的实例演示](https://blog.csdn.net/cout_sev/article/details/24628903)
    - 一个20节点的红黑树的构建过程及单步分析(ta也有引用别的文章, 但原文只有流程图, 没有讲解), 图示十分详细, 涉及到5种旋转.
2. [教你透彻了解红黑树](https://segmentfault.com/a/1190000000472153)
    - 没有涉及对**3.3.3**节中情况的处理
3. [30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)
    - 明确指出**3.3.3**情况的解决方法
    - "红黑树的生长是自底向上的"意思是, 找到节点插入的位置非常简单, 但是维护树的平衡则需要从下而上遍历.

红黑树的5个特性

1. 节点是红色或黑色
2. 根节点是黑色
3. 所有叶子节点(NIL节点, 空节点)是黑色的
4. 每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

其实只有4和5比较重要, 在插入/删除操作中因为这两个约束才会有旋转和变色的操作.

------

新插入节点默认为红.

> 如果默认为黑的话, 想想, 从插入第一个节点开始, 红节点还有机会吗? 全黑不就好了吗? 还玩什么?

网上很多文章要么把插入操作遇到的情况过度复杂化, 要么就是理论与配图分开, 阅读的时候还要来回对照, 太烦人.

本文在描绘插入流程中的红黑树形态时不显示`nil(B)`节点(这个只会影响第5条约束), 只在必要时提及.

## 1. 根节点

原本的红黑树为空的, 第一个节点就是根节点, 那么直接染黑.

## 2. 父节点为黑

```
         P(B)            P(B) 
       /                      \
    N(R)                       N(R)
```

就比如树中的第2个节点, 根节点为黑, 可以直接插入, 不影响红黑树特性.

## 3. 父节点为红

这种情况违反了红黑树的第4条约束(出现两个连续的红色节点), 要想办法解决.

现在可以确定的是:

1. 那父节点肯定不能是根节点(根节点必须为黑)
2. 祖父结点肯定是黑(反正不能和父节点一样是红)

现在不能确定的有:

1. 是否存在叔叔节点, 以及叔叔节点的颜色是黑还是红;
2. 新节点是父节点的左节点还是右节点;
3. 父节点是祖父节点的左节点还是右节点;

```
            GP(B)
          /       \
        P(R)      U(?)
      /
   N(R)
```

- `N`:  New             待插入节点
- `P`:  Parent          父亲节点
- `U`:  Uncle           叔叔节点
- `GP`: Grandparent     祖父节点

### 3.1 叔叔节点不存在

从理论上讲不可能出现这种情况, 假设实际上存在如下形态的树.

```
            7(B)
          /
        5(R)
      /
    3(R)
```

其中节点3在是待插入的新节点, 那么在程序眼中, 其实是是这样的.

```
            7(B)
          /      \
        5(R)     nil(B)
      /     \
    3(R)    nil(B)
  /     \
nil(B)  nil(B)
```

红黑树中所有的空位都会被`nil(B)`节点填充, 这种情况下叔叔节点被当作黑色处理.

### 3.2 叔叔节点存在且为黑

按照新节点与父节点分属左还是右的不确定性, 大致有下面4种情况, 这里统一说了.

```
            GP(B)             |             GP(B)               
          /       \           |           /       \             
        P(R)      U(B)        |         P(R)      U(B)          
      /                       |             \                   
   N(R)                     1 | 2            N(R)               
------------------------------|---------------------------------
            GP(B)           3 | 4           GP(B)               
          /       \           |           /       \             
        U(B)      P(R)        |         U(B)      P(R)          
                     \        |                 /               
                     N(R)     |              N(R)               
```

是不是觉得与AVL的四种旋转方式有点像? 其实单从旋转操作来说, 完全一样, 但多了着色的判断. 而且这4种情况的处理也是极为相似的, 第2种情况会首先通过纯粹的左旋转换成第1种, 同样第4种也会先通过纯粹的右旋转换成第3种.

以第2种情况为例, 对应AVL树中LR型调整.

```
        GP(B)         =>           GP(B)        =>         N(B)          
      /       \                  /       \               /     \         
    P(R)      U(B)             N(R)      U(B)          P(R)    GP(R)     
        \                    /                                     \     
         N(R)              P(R)                                     U(B)  
```

1. 对应平衡二叉树中`LR`型旋转的第1步`LL`左旋, 节点颜色上无操作, 形成类似于上面第1种情况的树形态(注意第1种情况中N < P, 第2种情况中 N > P), 之后的操作与第1种情况完全相同;
2. 可以先交换GP与N的颜色(在第1种情况中即交换GP与P的颜色), 然后进行`LR`中的第2步`RR`右旋.

### 3.3 叔叔节点存在且为红

那就是父节点与叔叔节点都为红了, 首先就是把`P`/`U`的颜色与`GP`的调换一下.

```
            GP(B)            =>             GP(R)          
          /       \                       /       \        
        P(R)      U(R)                  P(B)      U(B)     
      /                               /                    
   N(R)                            N(R)                    
```

此时就需要考虑一些情况:

1. GP的父节点为黑
2. GP的父节点为红
3. GP是根节点(不能为红)

现在分别讲解ta们各自的处理方法

> 当然, 这种情况(叔叔节点存在且为红)下, 也会因为新节点与父节点分属左还是右的不确定性, 存在**4种情况**, 这里就不列举了, 见**3.2**.

#### 3.3.1 GP的父节点为黑

这种情况最简单了, 什么都不用做.

#### 3.3.2 GP的父节点为红

```
               GGP(R)     
             /            
           GP(R)          
         /       \        
       P(B)      U(B)     
     /                    
  N(R)                    
```

有没有觉得这个形态有些眼熟? 

如果忽略节点`N(R)`, 向上回溯, 会发现现在的情况回到了本节(**3. 父节点为红**)开始的地方.

现在又需要重新考虑:

1. 是否存在叔叔节点`GU`, 以及叔叔节点的颜色是黑还是红;
2. 新节点`P`是父节点`GP`的左节点还是右节点;
3. 父节点`GP`是祖父节点`GGP`的左节点还是右节点;

```
           GGP(R)                    GGP(R)       
         /                         /        \     
      GP(R)                     GP(R)        GU(?)
    /       \                 /       \           
  P(B)      U(B)            P(B)      U(B)        
```

- `GU`:     grand uncle         叔祖父
- `GPP`:    grand grandparent   曾祖父

在程序中, 只要把表示当前节点的对象从`N(R)`后指回到`GP(R)`, 就是说把`GP(R)`当作新插入节点, 再次执行整个流程(**3. 父节点为红**)即可.

#### 3.3.3 GP是根节点

节点`GP`为根节点, 就说明不会存在**3.3.2**中的`GGP`节点, 在这种情况下, 直接再把根节点染黑即可.

```
           根节点                            根节点          
           GP(R)            =>              GP(B)          
         /       \                        /       \        
       P(B)      U(B)                   P(B)      U(B)     
     /                                /                    
  N(R)                             N(R)                    
```

> 从根结点到叶子结点的路径中, 黑色结点增加了. 这也是唯一一种会增加红黑树黑色结点层数的插入情景.

