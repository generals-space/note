# 平衡树构造与旋转.1

参考文章

1. [平衡二叉树](https://blog.csdn.net/isunbin/article/details/81707606)
    - 平衡二叉树(AVL树)的成型条件, 与非平衡二叉树的对比.
    - 图解, 非常详细.
    - 构造平衡二叉树与删除树节点的C语言代码示例(前序遍历), 分为LL, RR, LR, RL四种调整类型.
    - 平衡因子: 将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)
    - 最小不平衡子树: 距离插入节点最近的, 且平衡因子的绝对值大于1的节点为根的子树(其实就是发生不平衡处的子树).

由于在构造平衡树的过程中时刻保持着平衡, 所以一旦发生失衡, 调整所需要的旋转操作最多只需要两次, 不会出现由于底层子树旋转导致上层子树重新陷入失衡的情况.

但是删除节点就不一样了, 删除节点导致的失衡需要回溯到根节点不断重新检测, 如果这棵平衡二叉树很高的话, 那中间就要判断很多个节点.

## LL型

```
            4         =>                     4
          /   \                            /   \
node ->  3     5                          2     5
       /                                /   \
      2                    newNode ->  1     3 <- node
    /                                  
   1  <- newNode                       
```

> `node`节点表示最小不平衡子树的根节点, 即二叉树出现不平衡的根源.

参考文章1中关于`LL`型调整的解释, 给出了`A -> B -> C`的示例, 对应上面的`3 -> 2 -> 1`. 

参考文章1还说: "LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)", 对应到上图则是说节点2不一定为空. 

不为空的情况上面已经给出了, 那么节点2为空又是什么情况呢? 其实就对应了`RL`型的调整, 可以查看下面的`RL`型调整的第1步.

## RR型

```
       2               =>                 2
     /   \                              /   \
    1     3  <- node                   1     4
            \                              /   \
             4                   node ->  3     5  <- newNode
               \                 
     newNode->  5                

```

## LR型

```
                        RR(node.left)                LL            
                4       =>                 4         =>                      4
              /   \                      /   \                             /   \
    node ->  3     5           node ->  3     5                           2     5
           /                          /                                 /   \
          1                          2  <-newNode          newNode ->  1     3  <-node
            \                      /                                    
  newNode -> 2                    1                              

```

`LR`第1步的`RR`操作, `1 -> 2`的变化等同于上面`RR`中的`3 -> 4`, 不过前者中的节点2没有右节点, 后者中的节点4则有右节点5.

## RL型

```
                         LL(node.right)                    RR            
      2                  =>             2                  =>               2
    /   \                             /   \                               /   \
   1     4  <- node                  1     4  <- node                    1     3  <- node
           \                                 \                               /   \
            5                      newNode ->  3                   node ->  4     5
          /                                     \                           
         3  <- newNode                           5                          
```

`RL`第1步的`LL`操作, `5 -> 3`的变化等同于上面`LL`中的`3 -> 2`, 不过前者中的节点3没有左节点, 后者中的节点2则有左节点1.

