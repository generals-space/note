# 正则表达式场景练习

## 1. 通用

### 1.1 反向选择

匹配不以hello开头的行? 匹配不以world结尾的行？

```
$ cat file.txt
hello world
you hello
good work
```

`grep`命令的`-v`选项可以实现反向选择.

```
## 显示以hello开头的行
$ egrep '^hello' file.txt
hello world
## 显示不以hello开头的行
$ egrep -v '^hello' file.txt
you hello
```

`sed`的`!`操作符可以实现反向选择并打印

```
$ sed -nr '/^hello/p' ./file.txt
hello world
$ sed -nr '/^hello/!p' ./file.txt
you hello
good work
```

> 思考: 不使用命令工具提供的方式, 单纯用正则是否能实现这个要求??

## 2. sed

参考文章

[文本处理工具之二sed命令详解](http://www.2cto.com/os/201406/308604.html)

`sed`命令常用的功能有

- `p`: 打印

- `s`: 替换

- `a`: 追加

- `d`: 删除

### 2.0 基本操作方法

```
$ cat file.txt
hello world
you hello
good work

## 追加行, 注意`a`与待追加的内容之间的分割符.
$ sed -ri '/world/a\good' file.txt
$ cat file.txt
hello world
good
you hello
good work
```

### 2.1 行内指定字符 or 整行 ?

处理文本时, 大致可以将`sed`的行为分成`匹配` + `操作`这两个过程, `s`面向的是匹配到的字符串, 而`p`, `d`, `a`面向的是包含匹配字符串的整行.

比如:

```
$ cat file.txt
hello world
you hello
good work

## 将以hello开头的行匹配到的hello替换成cool.
## 注意第4行`you hello`没有被替换
$ sed -ir 's/^hello/cool/g' ./file.txt
$ cat file.txt
cool world
cool kitty
cool kugou
you hello
good work

## 这样可以匹配到包含hello这个单词的行, 从而实现替换
$ sed  -ir 's/hello/cool/g' ./file.txt
$ cat file.txt
cool world
cool kitty
cool kugou
you cool
good work
```


```
$ cat file.txt
hello world
you hello
good work

$ sed -d '/hello/d' file.txt
$ cat file.txt
good work
```

### 分组/引用

会使用到这个概念的, 一般是在`s`的替换操作中. 我们已经知道, `s`操作面向的不是匹配到目标字符串的整行, 而是匹配指定模式的字符串本身. 而`&`(and符号)可以引用指定模式所匹配到的字符串(同一行内可能不只一处匹配到, 使用`s`操作的`g`标记会引用本行所有匹配到的字符).

```
$ cat file.txt
hello world
you hello
good work

## 在每个hello字符串后添加000
$ sed -ir 's/hello/&000/g' file.txt
$ cat file.txt
hello000 world
you hello000
good work

## 或者只在以hello开头的行的hello字符串后添加000
$ sed -ir 's/^hello/&000/g' file.txt
$ cat file.txt
hello000 world
you hello
good work
```

关于分组, 分组的创建使用'('与')', 注意转义. '\1'到'\9'可引用匹配到的第1到第9个分组, 而上面讲到的`&`则可以看成所有分组的集合.

```
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0

## 在第1列的数字后加上000(比如时间单位弄错了, 秒需要替换成毫秒)
## 注意`s`操作第2段斜线中''\1', 就是引用的前面'^([0-9]*)'的分组,
## 而且追加的内容与'\1'之间没有空格, 这下知道为什么分组只能分到'\1'到'\9'了吧
## 因为'\10'就表示在第1个分组后追加'0'了.
$ sed -ri 's/^([0-9]+)/\1000/g' file.txt
$ cat file.txt
199841605000 4 45151746 1 0
199841886000 6 109136864 16 0
199841950000 6 109132544 16 0
```

再比如

```
$ cat file.txt
199841605  4 45151746 1 0
199841886  6 109136864 16 0
199841950  6 109132544 16 0
199842374 6 109142594 16 0
## 第一列数据后有两个空格的行, 去除一个空格
$ sed -ri 's/^([0-9]+)(  )/\1 /' 目标文件名
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0
199842374 6 109142594 16 0
```

**注意**

上面所说分组方式有一个前提: `r`选项在`i`选项前面, 如果组合方式为`-ir`, 会出问题. 比如

```
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0

$ sed -ir 's/^([0-9]+)/\1000/g' file.txt
sed: -e expression #1, char 19: invalid reference \1 on `s' command's RHS
## 这种情况下可能需要把用作分组的'()'使用'\'进行转义, 另外'+'也不能使用, 分情况用'*'代替
$ sed -ir 's/^\([0-9]*\)/\1000/g' file.txt
$ cat file.txt
199841605000 4 45151746 1 0
199841886000 6 109136864 16 0
199841950000 6 109132544 16 0
```

然而, 使用`-sr`(`s`选项在`r`之前)进行替换预览却没有这个问题.

```
$ cat file.txt
199841605 4 45151746 1 0
199841886 6 109136864 16 0
199841950 6 109132544 16 0

$ sed -sr 's/^([0-9]+)/\1000/g' file.txt
199841605000 4 45151746 1 0
199841886000 6 109136864 16 0
199841950000 6 109132544 16 0
```

简直了...当前版本`sed (GNU sed) 4.2.2`, 这种情况简直匪夷所思.

------

sed
匹配单词边界 `\<` 和 `\>`


## grep

grep无法进行跨行匹配,
			
grep无分组的概念, 无法只显示某一分组的值, 但是-o选项可以只输出匹配的部分,
`-P`选项赋予shell与perl功能类似的非贪心匹配的能力, 但貌似有许多发行版不支持.

非贪心匹配. 在选取html标签时, 得到最内层的标签

```
## 将得到最内层的标签
$ grep -Po '<div>.*?</div>'

## 将得到范围尽量大的div标签
$ grep -o  '<div>.*</div>'		
```

`-o`选项: 只输出行内匹配的选项而不是输出匹配目标表达式的整行.