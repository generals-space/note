# redis集群搭建

参考文章

1. [Redis Sentinel(哨兵)：集群解决方案](http://p.primeton.com/articles/559e431d608f8f5438000059)

哨兵模式使用上述提到的`一主一从`或`一主多从`的模式, 并额外启动一个或多个名叫`sentinel(哨兵)`的进程. 其实现的主要功能有:

- 监控(Monitoring): Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- 提醒(Notification): 当被监控的集群中某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
- 自动故障迁移(Automatic failover): 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。

...好像可以看作是同一个作用.

## 1. 基本配置

redis编译完成后, src目录下存在一个名为`redis-sentinel`的可执行文件. 其实sentinel是一个特殊的redis-server进程, 使用`diff ./redis-sentinel ./redis-server`可以看出, 这俩货明明是同一个文件...

所以可以在其配值文件`sentinel.conf`中指定`daemonize`, `pid`, `logfile`等字段的值. 可以尝试一下.

结合具体流程说一下.

1. 首先需要启动`master`, `slave1`, `slave2`...等多个redis-server进程. 一般来说, 除了IP与端口, 他们的配置基本相同.
2. 目前他们都是平等的, 然后在所有你想让他们成为从节点的节点上, 通过cli设置`slaveof master的IP master的端口`, 形成一主多从的结构, 从节点将共享主节点上的数据但只能读.
3. 接下来即可启动sentinel进程.

sentinel的配置文件为redis根目录下的`sentinel.conf`, 其最小配置为

```
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
```

在上面所示的配置文件中.

### 1.1 sentinel monitor

这一行在sentinel.conf初始文件中的原型如下.

```
sentinel monitor <master-name> <ip> <redis-port> <quorum>
```

`<master-name>`为目标集群的名称, 可以随便设置, 不过最好取有意义的名称, 方便识别. 示例中为`mymaster`.

之后`<ip> <redis-port>`为初始时master节点的IP与端口(注意是 **初始时** , 这个将在本节后面部分解释).

然后`<quorum>`是一个数值, 翻译过来是`法定人数`的意思, 它的取值 **十分重要** . 意思是至少当几个sentinel进程发现`mymaster`集群中master进程挂掉时, 才会确认这个master进程真的挂掉了.

比如为一个主从集群创建了3个sentinel进程同时监视, quorum设置为2, 当其中某个sentinel进程因为网络问题无法连接master服务(不过与其他sentinel进程可以通信), 它会主观认为master挂掉, 将其状态设置为`Subjectively Down(主观下线)`. 但是另外两个sentinel网络正常, 认为master挂的进程数量只有一个, 是不会执行故障迁移的. 当>=2个sentinel都认为master服务挂掉, 它们就会将原master进程屏蔽掉, 提升某个slave为master.

但是, 就算将这个值设置为1, 其中某个sentinel主观判断master失效, 但是另外两个认为master正常, sentinel组依然不会同意进行故障迁移. 即 **无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数(majority) Sentinel 的支持， 才能发起一次自动故障迁移**. 所以, 可以认为, 只有`quorum`的取值 **大于sentinel进程总数的一半** 时才会真正起作用, 否则设置它就没有意义.

### 1.2 sentinel down-after-milliseconds

指定了此 Sentinel 认为服务器已经断线所需的毫秒数。

如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线.

### 1.3 sentinel parallel-syncs

指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长，但越大就意味着越多的从服务器因为复制而不可用。可以通过将这个值设为 1 来保证每次只有一个从服务器处于不能处理命令请求的状态。

我对这段话的理解是, 假设一个集群中有`master`, `slave1`, `slave2`, `slave3`, `slave4`5个进程, 只有master对外进行写服务, slave节点提供读服务. 当`master`挂掉, `slave1`被sentinel选出来当作新的`master`, 那么`slave2`, `slave3`与`slave4`将需要以slave1为主节点进行数据同步. 如果`parallel-syncs`的值设置为2, 那么新的slave节点里将会有两个节点, 这里假设为`slave2`与`slave3`, 从新的`master`节点拉取数据, 这段时间里它们将 **不能对外提供读服务** . 当他们两个复制完成, 才轮到`slave3`. 只有当`slave3`也完成了数据同步, 故障转移才算完全完成.

所以说, 当这个值越小, 故障转移的时间越长, 出问题的可能性越大(比如在故障转移过程中, 新的master节点又挂 掉). 但又不能因为要减少故障转移的时间将其值设置过大, 这将影响其他slave节点对外读服务的效率.

## 2. 注意事项

sentinel模式的应用还是比较简单的. 在slave节点的cli设置slaveof, 并设置sentinel所监听的master节点地址后, 直接启动sentinel就行了.

sentinel进程可以自动检测到目标master节点的所有可用slave节点, 并且一个master的所有sentinel也会自动检测到彼此的存在, 形成sentinel组.

### 2.1 sentinel数量及quorum值的设置

最好sentinel的进程数量为>2的奇数. 我踩过的坑是, 启动两个sentinel, `monitor`字段的quorum设置为1, 当单独kill掉redis的master时, 可以执行故障转移, 但是如果将master与其中一个sentinel同时kill掉就惨了. 剩下的那个sentinel虽然已经达到quorum的标准, 但它不能让sentinel组中超过一半都同意它...因为2个成员的sentinel组现在只剩它自己, 而1/2是不大于50%的. 所以整个集群都挂了...

### 2.2 sentinel配置重写

这是个令人心碎的事情. sentinel进程启动后会自动检测到目标master的所有slave, 以及其他同样监听这个master的所有其他sentinel, 并且记录下来.

sentinel会将这些记录追加到sentinel.conf文件末尾. 并且, 每当主从切换, 所有sentinel将会把新的master节点地址写到`sentinel monitor`字段中. 如果一个sentinel监控多个redis集群, 最后其配置文件将会被改的乱七八遭, 不忍直视.


如下

```
...
sentinel leader-epoch cluster6381 1
sentinel config-epoch cluster6381 2
sentinel known-slave cluster6381 192.168.169.130 6381
sentinel known-sentinel cluster6381 192.168.169.136 26379 cfd9da115d8034f75d87e7f300ab3363c3077732
...
```

其中`leader-epoch`与`config-epoch`在之后解释.

另外redis-server启动的服务, 其配置文件`redis.conf`也会被修改. 从节点将保留下其主节点的配置, 如下.

```
# Generated by CONFIG REWRITE
save 900 1
save 300 10
save 60 10000
dir "/usr/local/redis/data"
slaveof 192.168.169.136 6381
cluster-require-full-coverage no
```

在做实验时, 如果想要启动一个主节点, 请首先确认其`redis.conf`, 这些被之前实验中的redis/sentinel进程修改过的配置将会严重影响之后实验的正确性.

## 3. 客户端的设置

目前大多数redis客户端都支持sentinel模式, 以`Predis`为例

```php
<?php
	require_once 'Predis/src/Autoloader.php';
    Predis\Autoloader::register();
    ##这里是所有sentinel的地址, 少量sentinel进程死掉不会影响客户端读写.
	$sentinel = array(
		'tcp://192.168.169.130:26379',
		'tcp://192.168.169.140:26379',
	);
	$options = array(
		'replication' => 'sentinel',
		'service' => 'cluster6381'
	);
	$client = new Predis\Client($sentinel, $options);

	$client->set('key1', 'val1');
	$client->set('key2', 'val2');

	$value = $client->get('key1');
	echo $value."\n";
	$value = $client->get('key2');
	echo $value."\n";
?>

```
