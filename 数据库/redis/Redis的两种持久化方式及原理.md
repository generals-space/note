# redis 的两种持久化方式及原理

参考文章

[redis 的两种持久化方式及原理](http://zhengdl126.iteye.com/blog/2191834)

Redis是一种高级key-value数据库. 它跟memcached类似, 不过数据可以持久化, 而且支持的数据类型很丰富. 有字符串, 链表, 集合和有序集合. 支持在服务器端计算集合的并, 交和补集(difference)等, 还支持多种排序功能. 所以Redis也可以被看成是一个数据结构服务器. 

Redis的所有数据都是保存在内存中, 需要经常将内存中的数据同步到磁盘来保证持久化. redis支持两种持久化方式, 一种是 `Snapshotting`（快照）也是默认方式, 称为 **`半持久化模式`** ;另一种是`Append-only file`（缩写aof）的方式, 称为**`全持久化模式`** . 

## 1. 简介

### 1.1 Snapshotting

默认redis会以**快照**的形式将数据持久化到磁盘（这是一个二进制文件, dump.rdb, 文件名及其路径可以指定）, 在配置文件中的格式是：`save N M` 表示在N秒之内, redis至少发生M次修改则redis抓快照到磁盘. 当然我们也可以在`cli`终端手动执行`save`或者`bgsave`（异步）做快照. 

```
less redis.conf
...
save 900 1  #900秒内如果超过1个key被修改, 则发起快照保存
save 300 10 #300秒内容如超过10个key被修改, 则发起快照保存
save 60 10000
```

工作原理：当redis需要做持久化时, redis会fork一个子进程, 子进程将数据写到磁盘上一个临时RDB文件中, 当子进程完成写临时文件后, 将原来的RDB文件替换掉.

在cli终端下也可以使用`save`或者`bgsave`命令通知redis做一次快照持久化. `save`操作是**在主线程中保存快照**的, 由于redis是用一个主线程来处理所有 client的请求, 这种方式会**阻塞所有请求**. 所以不推荐使用. 

注意, **每次快照持久化都是将内存数据完整写入到磁盘一次, 并不是增量的只同步脏数据**. 如果数据量大, 而且写操作比较多, 必然会引起大量的磁盘io操作, 可能会严重影响性能. 

### 1.2 Append-Only

`Snapshotting`方法在redis异常死掉时, 最近的数据会丢失（丢失数据的多少视你save策略的配置）, 所以这是它最大的缺点, 当业务量很大时, 丢失的数据是很多的. `Append-only`方法可以做到全部数据不丢失, 但性能就要差些. 

AOF就可以做到全程持久化, 只需要在配置文件中开启（默认是no）, `appendonly yes`开启AOF之后, redis每执行一个修改数据的命令, 都会把它添加到aof文件(这是一个文本文件)中, 当redis重启时, 将会读取AOF文件进行**重放**以恢复到 redis关闭前的最后时刻. 

并且`LOG Rewriting`随着修改数据的执行AOF文件会越来越大, 其中很多内容记录某一个key的变化情况. 因此redis有了一种比较有意思的特性：在后台重建AOF文件, 而不会影响client端操作. 在任何时候执行BGREWRITEAOF命令, 都会把当前内存中最短序列的命令写到磁盘, 这些命令可以完全构建当前的数据情况, 而不会存在多余的变化情况（比如状态变化, 计数器变化等）, 缩小的AOF文件的大小. 所以当使用AOF时, redis推荐同时使用BGREWRITEAOF. 

AOF文件刷新的方式(对应配置参数`appendfsync`):

- `appendfsync always`: 每提交一个修改命令都调用fsync刷新到AOF文件, 非常非常慢, 但也非常安全；

- `appendfsync everysec`: 每秒钟都调用fsync刷新到AOF文件, 很快, 但可能会丢失一秒以内的数据；

- `appendfsync no`: 依靠OS进行刷新, redis不主动刷新AOF, 这样最快, 但安全性就差. 

默认并推荐每秒刷新, 这样在速度和安全上都做到了兼顾. 

可能由于系统原因导致了AOF损坏, redis无法再加载这个AOF, 可以按照下面步骤来修复：首先做一个AOF文件的备份, 复制到其他地方；修复原始AOF文件, 执行：$ redis-check-aof –fix ;可以通过diff –u命令来查看修复前后文件不一致的地方；重启redis服务. 

LOG Rewrite的工作原理: 同样用到了copy-on-write. 首先redis会fork一个子进程；子进程将最新的AOF写入一个临时文件；父进程 增量的把内存中的最新执行的修改写入（这时仍写入旧的AOF, rewrite如果失败也是安全的）；当子进程完成rewrite临时文件后, 父进程会收到 一个信号, 并把之前内存中增量的修改写入临时文件末尾；这时redis将旧AOF文件重命名, 临时文件重命名, 开始向新的AOF中写入. 

最后, 为以防万一（机器坏掉或磁盘坏掉）, 记得定期把使用 filesnapshotting 或 Append-only 生成的\*.rdb, \*.aof文件备份到远程机器上. 我是用crontab每半小时SCP一次. 我没有使用redis的主从功能 , 因为半小时备份一次应该是可以了, 而且我觉得有如果做主从有点浪费机器. 这个最终还是看应用来定了. 
