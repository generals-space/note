# 面向程序员的数据库访问性能优化法则

原文链接

[面向程序员的数据库访问性能优化法则](https://blog.csdn.net/yzsind/article/details/6059209)

## 1 创建并使用正确的索引

数据库索引的原理非常简单, 但在复杂的表中真正能正确使用索引的人很少, 即使是专业的DBA也不一定能完全做到最优. 

索引会大大增加表记录的DML(`INSERT`,`UPDATE`,`DELETE`)开销, 正确的索引可以让性能提升100, 1000倍以上, 不合理的索引也可能会让性能下降100倍, 因此在一个表中创建什么样的索引需要平衡各种业务需求. 

索引常见问题: 

### 1.1 索引有哪些种类? 

常见的索引有B-TREE索引、位图索引、全文索引, 位图索引一般用于数据仓库应用, 全文索引由于使用较少, 这里不深入介绍. B-TREE索引包括很多扩展类型, 如组合索引、反向索引、函数索引等等, 以下是B-TREE索引的简单介绍: 

B-TREE索引也称为平衡树索引(Balance Tree), 它是一种按字段排好序的树形目录结构, 主要用于提升查询性能和唯一约束支持. B-TREE索引的内容包括根节点、分支节点、叶子节点. 

**叶子节点内容**: 索引字段内容+表记录ROWID

**根节点, 分支节点内容**: 当一个数据块中不能放下所有索引字段数据时, 就会形成树形的根节点或分支节点, 根节点与分支节点保存了索引树的顺序及各层级间的引用关系. 

一个普通的BTREE索引结构示意图如下所示: 

![](https://gitee.com/generals-space/gitimg/raw/master/83aaff14162798225e9576e571a0d4a6.gif)

如果我们把一个表的内容认为是一本字典, 那索引就相当于字典的目录, 如下图所示: 

![](https://gitee.com/generals-space/gitimg/raw/master/76c18e95eeae959cc2d93047652481c2.gif)

![](https://gitee.com/generals-space/gitimg/raw/master/7ed3c1d51e2f3a43a5de3b803365aeea.gif)

图中是一个字典按部首+笔划数的目录, 相当于给字典建了一个按部首+笔划的组合索引. 

一个表中可以建多个索引, 就如一本字典可以建多个目录一样（按拼音、笔划、部首等等）. 

一个索引也可以由多个字段组成, 称为组合索引, 如上图就是一个按部首+笔划的组合目录. 

SQL什么条件会使用索引? 

当字段上建有索引时, 通常以下情况会使用索引: 

- `INDEX_COLUMN =/>/>=/</<= ?`
- `INDEX_COLUMN between ? and ?`
- `INDEX_COLUMN in (?,?,...,?)`
- `INDEX_COLUMN like ?||'%'（后导模糊查询）`
- `T1.INDEX_COLUMN=T2. COLUMN1（两个表通过索引字段关联）`

### 1.2 SQL什么条件不会使用索引? 

1. 不等于操作不能使用索引
    - `INDEX_COLUMN <> ?`
    - `INDEX_COLUMN not in (?,?,...,?)`
2. 经过普通运算或函数运算后的索引字段不能使用索引
   - `function(INDEX_COLUMN) = ?`
   - `INDEX_COLUMN + 1 = ?`
   - `INDEX_COLUMN || 'a' = ?`
3. 含前导模糊查询的Like语法不能使用索引
   - `INDEX_COLUMN like '%'||?`
   - `INDEX_COLUMN like '%'||?||'%'`
4. B-TREE索引里不保存字段为NULL值记录, 因此IS NULL不能使用索引
   - `INDEX_COLUMN is null`
5. Oracle在做数值比较时需要将两边的数据转换成同一种数据类型, 如果两边数据类型不同时会对字段值隐式转换, 相当于加了一层函数处理, 所以不能使用索引. 
   - `NUMBER_INDEX_COLUMN='12345'`
   - `CHAR_INDEX_COLUMN=12345`
6. 给索引查询的值应是已知数据, 不能是未知字段值. 
   - `a.INDEX_COLUMN=a.COLUMN_1`

注意

1. 经过函数运算字段的字段要使用可以使用函数索引, 这种需求建议与DBA沟通. 
2. 有时候我们会使用多个字段的组合索引, 如果查询条件中第一个字段不能使用索引, 那整个查询也不能使用索引

如: 我们company表建了一个id+name的组合索引, 以下SQL是不能使用索引的

```sql
select * from company where name = ?
```

3. Oracle9i后引入了一种index skip scan的索引方式来解决类似的问题, 但是通过index skip scan提高性能的条件比较特殊, 使用不好反而性能会更差. 

### 1.3 我们一般在什么字段上建索引? 

这是一个非常复杂的话题, 需要对业务及数据充分分析后再能得出结果. 主键及外键通常都要有索引, 其它需要建索引的字段应满足以下条件: 

1. 字段出现在查询条件中, 并且查询条件可以使用索引；
2. 查询语句执行频率高, 一天会有几千次以上；
3. 通过字段条件可筛选的记录集很小, 那数据筛选比例是多少才适合? 

这个没有固定值, 需要根据表数据量来评估, 以下是经验公式, 可用于快速评估: 

小表(记录数小于10000行的表): 筛选比例<10%；

大表: (筛选返回记录数)<(表总记录数*单条记录长度)/10000/16

      单条记录长度≈字段平均内容长度之和+字段数*2

以下是一些字段是否需要建B-TREE索引的经验分类: 

1. 需要建索引的字段
   - 主键. 常见字段名: ID,PK
   - 外键. 常见字段名: PRODUCT_ID,COMPANY_ID,MEMBER_ID,ORDER_ID,TRADE_ID,PAY_ID
   - 有对像或身份标识意义字段. 常见字段名: HASH_CODE,USERNAME,IDCARD_NO,EMAIL,TEL_NO,IM_NO
2. 索引慎用字段,需要进行数据分布及使用场景详细评估
   - 日期. 常见字段名: GMT_CREATE,GMT_MODIFIED
   - 年月. 常见字段名: YEAR,MONTH
   - 状态标志. 常见字段名: PRODUCT_STATUS,ORDER_STATUS,IS_DELETE,VIP_FLAG
   - 类型. 常见字段名: ORDER_TYPE,IMAGE_TYPE,GENDER,CURRENCY_TYPE
   - 区域. 常见字段名: COUNTRY,PROVINCE,CITY
   - 操作人员. 常见字段名: CREATOR,AUDITOR
   - 数值. 常见字段名: LEVEL,AMOUNT,SCORE
   - 长字符. 常见字段名: ADDRESS,COMPANY_NAME,SUMMARY,SUBJECT
3. 不适合建索引的字段
   - 描述备注. 常见字段名: DESCRIPTION,REMARK,MEMO,DETAIL
   - 大字段. 常见字段名: FILE_CONTENT,EMAIL_CONTENT

### 1.4 如何知道SQL是否使用了正确的索引? 

简单SQL可以根据索引使用语法规则判断, 复杂的SQL不好办, 判断SQL的响应时间是一种策略, 但是这会受到数据量、主机负载及缓存等因素的影响, 有时数据全在缓存里, 可能全表访问的时间比索引访问时间还少. 要准确知道索引是否正确使用, 需要到数据库中查看SQL真实的执行计划, 这个话题比较复杂, 详见SQL执行计划专题介绍. 

### 1.5 索引对DML(INSERT,UPDATE,DELETE)附加的开销有多少? 

这个没有固定的比例, 与每个表记录的大小及索引字段大小密切相关, 以下是一个普通表测试数据, 仅供参考: 

- 索引对于Insert性能降低56%
- 索引对于Update性能降低47%
- 索引对于Delete性能降低29%

因此对于写IO压力比较大的系统, 表的索引需要仔细评估必要性, 另外索引也会占用一定的存储空间. 

## 2 只通过索引访问数据

有些时候, 我们只是访问表中的几个字段, 并且字段内容较少, 我们可以为这几个字段单独建立一个组合索引, 这样就可以直接只通过访问索引就能得到数据, 一般索引占用的磁盘空间比表小很多, 所以这种方式可以大大减少磁盘IO开销. 

如: 

```sql
select id,name from company where type='2';
```

如果这个SQL经常使用, 我们可以在type,id,name上创建组合索引

```sql
create index my_comb_index on company(type,id,name);
```

有了这个组合索引后, SQL就可以直接通过my_comb_index索引返回数据, 不需要访问company表. 

还是拿字典举例: 有一个需求, 需要查询一本汉语字典中所有汉字的个数, 如果我们的字典没有目录索引, 那我们只能从字典内容里一个一个字计数, 最后返回结果. 如果我们有一个拼音目录, 那就可以只访问拼音目录的汉字进行计数. 如果一本字典有1000页, 拼音目录有20页, 那我们的数据访问成本相当于全表访问的50分之一. 

**切记, 性能优化是无止境的, 当性能可以满足需求时即可, 不要过度优化. **在实际数据库中我们不可能把每个SQL请求的字段都建在索引里, 所以这种只通过索引访问数据的方法一般只用于核心应用, 也就是那种对核心表访问量最高且查询字段数据量很少的查询. 

## 3 优化SQL执行计划

SQL执行计划是关系型数据库最核心的技术之一, 它表示SQL执行时的数据访问算法. 由于业务需求越来越复杂, 表数据量也越来越大, 程序员越来越懒惰, SQL也需要支持非常复杂的业务逻辑, 但SQL的性能还需要提高, 因此, 优秀的关系型数据库除了需要支持复杂的SQL语法及更多函数外, 还需要有一套优秀的算法库来提高SQL性能. 

目前ORACLE有SQL执行计划的算法约300种, 而且一直在增加, 所以SQL执行计划是一个非常复杂的课题, 一个普通DBA能掌握50种就很不错了, 就算是资深DBA也不可能把每个执行计划的算法描述清楚. 虽然有这么多种算法, 但并不表示我们无法优化执行计划, 因为我们常用的SQL执行计划算法也就十几个, 如果一个程序员能把这十几个算法搞清楚, 那就掌握了80%的SQL执行计划调优知识. 

由于篇幅的原因, SQL执行计划需要专题介绍, 在这里就不多说了. 
