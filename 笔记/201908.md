FIFO: 命名管道. 可在文件系统中创建一个字符文件, 进程只要打开这个文件, 对其进行读写即可实现通信.
PIPE: 匿名管道. 内核提供的机制, 可使用`pipe()`函数创建一对文件描述符`fd[2]`, 但只能在父子进程间使用, 一般会立刻调用fork, 该fd也会复制到子进程空间. 数据通信貌似只能是单向的?

操作系统内核提供了很多机制, 比如IPC: 管道, 队列, 共享内存, socket等.

但编程语言没有必要使用这些机制进行通信, 比如很多第三方实现的mq, golang的channel, 就可方便地实现数据交换.

那ta们是怎么实现的呢? 申请内存, 加锁, 使用各种同步算法保持数据一致性... 总之, 提供的功能更加强大, 实现也更为复杂.

C语言对内核实现的这些机制只是提供了对应的接口而已(感觉很原始), 大型C程序也许也不会用到???

同样, 对于内核提供的一些锁机制: 进程间同步用的信号量, 线程间同步用的互斥锁, 内核级的自旋锁等...不过C标准库提供的这些机制也是内核接口? 没有自己的实现?

首先要说明一点, 先用C语言, 再有操作系统. 操作系统的API一般以C库的形式封装, 不过这些封装会对原生的系统调用做一些改动, 比如读写文件的函数会附加缓冲区, 某些依赖系统位数(32/64)的函数由C库决定调用哪一种等.

C标准库中的互斥锁由操作系统直接提供, 而golang的互斥锁是利用操作系统提供的信号量+自旋锁实现的.

像golang这种拥有GC的语言是不需要显式像操作系统申请内存然后释放的, golang会预先向操作系统申请内存并自行分配...也许这就是内置运行时的真谛???
