# Shell脚本技巧-格式化命令行参数

参考文章

[SHELL中对选项和参数的处理方法](http://smilejay.com/2010/12/shell-handle-options/)

[使用getopt处理shell脚本的参数](http://wangxiaoyu.blog.51cto.com/922065/624159/)

在bash中，可以用以下三种方式来处理命令行参数，每种方式都有自己适合的应用场景。

1. 直接处理，依次对$1,$2,…,$n进行解析，分别手工处理；

2. `getopts`，单个字符选项的情况（如:`-n 10`与`-f file.txt`等选项）；

3. `getopt`，可以处理单字符选项，也可以处理长选项（如:`–prefix=/home`等）。

一般小脚本手工处理也许就够了，`getopts`能处理绝大多数的情况，`getopt`较复杂、功能也更强大。

## 1. 

手工处理方式即使用`$@`, `$*`等隐含变量, 配合`shift`使用, 能满足多数的简单需求，构造出强大的功能，但处理复杂选项的时候建议用下面的两种方法。

## 2. getopts

`getopts`是shell内置的命令， 不能直接处理长选项（如:`–prefix=/home`等）. 接受两个参数，第一个参数是定义待解析选项的字符串, 第二个是一个自定义的变量. 如下

```
getopts 'a:bcd:' opt
```

参数1可以包含英文字符(区分大小写)和':'，每一个字符都是一个有效的选项，如果字符后面带有':'，表示这个字符后需要有自己的参数。

`getopts`会自动解析自己所在作用域内的`$*`参数列表. 如果遇到参数1中出现的带有`-`的字符, 比如`-a`, 它将会把这个字符也就是`a`赋值给参数2, 这里是`opt`变量. 这样就可以用`case...esac`语句匹配指定参数要执行的操作. 由于在参数1中`a`字符后面有一个冒号, 所以`getopts`会取出命令行中`-a`后紧接的参数并赋值给一个叫做`$OPTARG`的变量. 这个变量是`getopts`输出到脚本执行时所在的shell中的, 不需要自行定义.

然后`getopts`继续解析后面的参数, 这是一个循环过程, 所以一般搭配循环语句完成整个解析流程. 在这个过程中, `getopts`使用`$OPTIND`变量存储下一个待解析参数在命令行中的位置, 即索引值, 这个值从1开始. 同`$OPTARG`一样, 也是`getopts`输出到脚本中的.

### 2.1 示例讲解1-基础应用

```
#!/bin/bash
echo $*
while getopts 'a:b' opt
do
	case $opt in
	a) 
        echo 'a选项是有参数的, 这里取到它的参数为: ' $OPTARG
	    echo '此时命令行中待解析参数索引值:' $OPTIND
	    ;;
	b) 
        echo 'b选项无参数, 此时OPTARG变量的值为: ' $OPTARG        
	    echo '此时命令行中待解析参数索引值:' $OPTIND
            ;;
	?)
            echo 'error'
	    exit 1
           ;;
        esac
done
```

将其命名为`test1.sh`, 执行.

```
$ ./test1.sh -a abc -b
-a abc -b
a选项是有参数的, 这里取到它的参数为:  abc
此时命令行中待解析参数索引值: 3
b选项无参数, 此时OPTARG变量的值为:
此时命令行中待解析参数索引值: 4
```

`getopts`遇到`-a`选项, 由于在其参数1中有`a:`的定义, 说明a有一个参数, 于是`getopts`取得'abc'并将其赋值给`$OPTARG`, 此时`$OPTIND`指向`-b`的位置, 即为3.

取得`-b`后将`$OPTIND`指向其后的参数位置(虽然没有), 为4.

尝试执行`./test1.sh -a abc -b 123`, 会发现`getopts`并未取得123这个值, 因为`$OPTARG`依然为空. 这是因为`getopts`并未尝试去获取`-b`的参数, 而向后移动发现`123`不在其参数1中的列表里, 解析终止.

------

### 2.2 示例讲解2-解析终止

`getopts`解析终止的条件

1. 无参选项后接了一个参数

2. 出现一个不在参数1中的选项(可能是非法选项或多余参数)

仍然使用上述`test1.sh`为例.

**验证第1点**

```
$ ./test1.sh -b 123 -a abc
-b 123 -a abc
b选项无参数, 此时OPTARG变量的值为: 
此时命令行中待解析参数索引值: 2
```

`getopts`只会取得b选项, 到123处终止, 无法得到`-a`选项及其参数值.

**验证第2点**

```
$ ./test1.sh -a abc -c -b 
-a abc -c -b
a选项是有参数的, 这里取到它的参数为:  abc
此时命令行中待解析参数索引值: 3
./test1.sh: illegal option -- c
error

$ ./test1.sh -a abc 123 -b 
-a abc 123 -b
a选项是有参数的, 这里取到它的参数为:  abc
此时命令行中待解析参数索引值: 3
```

注意, 上面两种种是不同的情况, **非法选项会报错, 多余参数则直接停止**.

所以, `getopts`使用的注意点就是这里: 如果想要让`getopts`处理参数中的一部分, 脚本的其他内容处理剩余的部分, 则对`getopts`合法的部分与非法部分不能混杂, 必须严格分离.

```
$ 
```

### 2.3 示例讲解3-忽略错误

在`getopts`的参数1中将`:`作为第1个字符, 可以不显示非法参数的警告.

以上述`test1.sh`为例

```
$ ./test1.sh -a abc -c
-a abc -c
a选项是有参数的, 这里取到它的参数为:  abc
此时命令行中待解析参数索引值: 3
./test1.sh: illegal option -- c
error
```

在其基础上修改为

```
#!/bin/bash
echo $*
## 参数1开始处添加一个冒号, 忽略错误
while getopts ':a:b' opt
do
	case $opt in
	a) 
        echo 'a选项是有参数的, 这里取到它的参数为: ' $OPTARG
	    echo '此时命令行中待解析参数索引值:' $OPTIND
	    ;;
	b) 
        echo 'b选项无参数, 此时OPTARG变量的值为: ' $OPTARG        
	    echo '此时命令行中待解析参数索引值:' $OPTIND
        ;;
	?)
        echo 'error'
		## 移除自动退出操作
	    ## exit 1
        ;;
        esac
done
echo '解析完成'
```

再次执行

```
 ./test1.sh -a abc -c
-a abc -c
a选项是有参数的, 这里取到它的参数为:  abc
此时命令行中待解析参数索引值: 3
error
解析完成
```

如果在`?)..;;`的case语句中不跳过错误提示, 则不会再出现`illegal option`这样的输出.

### 2.4 示例讲解4-多参数

`getopts`的参数1中字符顺序没有严格限制. 比如使脚本接受`-a`和`-c`两个可以带参数的选项, 下面两种写法都是正确的.

```
getopts ':a:bc:' opt
getopts ':a:c:b' opt
```

## 3. getopt

`getopt`是`util-linux-ng`包中的工具, 不过大多数发行版默认安装了这个工具. 它是增强型的`getopts`, 可以处理长选项.

先来一个示例, 将以下脚本命名为`test1.sh`, 之后的讲解基于这个示例.

```
#!/bin/bash
echo '初始参数列表:' $@
## --是结束标志, 命令行中的参数解析完毕后, 会执行case语句中对应的匹配项
## $@为传入脚本的参数列表, getopt会对其进行解析并重新排序, ARGS是getopt重新排序后的参数列表字符串, 可以通过echo查看
ARGS=$(getopt -o a:c:b -l a-long:,c-long:,b-long -- "$@")
## `set -- 变量列表`, 会把变量列表中的变量按顺序赋值给$1, $2...相当于重写传入脚本的参数列表
eval set -- "${ARGS}"
echo '解析后的参数列表:' $@

while true
do
	case $1 in
		-a|--a-long)
			echo 'a选项是有参数的, 这里取到它的参数为: ' $2
			## 参数列表左移2位
            shift 2
			;;
		-c|--c-long)
			echo 'c选项是有参数的, 这里取到它的参数为: ' $2
			## 参数列表左移2位
            shift 2
			;;
		-b|--b-long)
			echo 'b选项无参'
			## 参数列表左移1位
            shift 1
			;;
		## '--'结束标记, 与ARGS=$(...)中的'--'对应
		--)
			shift 1
			break
		;;
		*)
			echo "invalid option"
			return 1
		;;
	esac
done
```

### 3.1 参数列表规则

`ARGS=$(getopt -o a:c:b -l a-long:,c-long:,b-long -- "$@")`

这一句就是将传入脚本的参数列表`$@`交给`getopt`解析. 关于可选选项参数列表的定义, `getopt`有两个选项.

- -o/--option: 普通短选项

- -l/--long: 长选项

还有一些其他的选项

- -n: 错误信息的提示符, 如`-n 'invalid option: '`

- -a: 使长参数支持'-'符号开头(而不是'--')，必须与`-l`同时使用

冒号的使用与`getopts`类似, 不带冒号的字符表示不需要参数, 带有一个冒号的字符表示需要一个参数, 还有带两个冒号的选项, 这个在后面会讲到.

需要注意的是长选项需要使用逗号','分隔.

### 3.2 参数列表顺序

`getopt`与`getopts`不同, `getopts`不会修改传入脚本的参数列表顺序, 如果中间混有多余的参数, 就会出错或停止解析; 而`getopt`需要对参数列表重新排序, 将多余参数移至最后, 程序可以对多余参数继续解析.

比如

```
$ ./test1.sh -a abc now -c 123
初始参数列表: -a abc now -c 123
解析后的参数列表: -a abc -c 123 -- now
a选项是有参数的, 这里取到它的参数为:  abc
c选项是有参数的, 这里取到它的参数为:  123
```

遇到非法选项就不是这样了, 未在参数列表中列出的选项, 会在`case`语句中匹配到`*)`这一段, 不过如果不在这里写`return`/`exit`语句的话, 也不会强制退出脚本的. 可以看到, 其实第2个`$@`的输出也得到了正确的参数列表.

比如

```
./test1.sh -a abc -d -c 123
初始参数列表: -a abc -d -c 123
getopt: invalid option -- 'd'
解析后的参数列表: -a abc -c 123 --
a选项是有参数的, 这里取到它的参数为:  abc
c选项是有参数的, 这里取到它的参数为:  123
```

------

关于`getopt`对参数列表顺序的修改, 需要理解`eval set -- "${ARGS}"`这一句. 

在这句之前打印ARGS的值, 如`echo $ARGS`. 

执行`./test1.sh -a abc -d -c 123`, 得到其输出为`-a 'abc' -c '123' --`, 与解析后的参数列表的输出是相同的. 

那这句`set -- ...`有什么作用呢?

将如下脚本保存为`test2.sh`. 

```
#!/bin/bash

set -- a b c
echo $1 $2 $3
```

直接执行, 不要加任何参数.

```
$ ./test2.sh 
a b c
```

可以看到, `set`配合`--`选项将其后面的参数赋值给了`$1`, `$2`..这些变量. `getopt`脚本中也是这样. 它将经过`getopt`解析的参数列表重新给`$1`,`$2`赋值, 于是之后的`while`循环可以通过`$1`,`$2`取得选项名称及参数值.

### 3.3 while循环与shift

`getopt`没有`getopts`中类似于`$OPTIND`的变量, 无法自动移动游标. 要维持循环, 需要使用`shift`将参数左移.

比如, 执行`./test1.sh -a abc now -c 123`. 经过解析的参数列表为`-a abc -c 123 -- now`.

在while循环中, 此时$1=-a, $2=now. 匹配到`case`语句中的判断条件后, `shift 2`将参数列表左移2位, 参数列表变为`-c 123 -- now`.

循环继续, 此时$1=-c, $2=123. 匹配到`case`语句中的判断条件, `shift 2`将参数列表左移2位, 参数列表变为`-- now`.

遇到`--`参数列表左移1位, 说明合法参数列表正常解析完毕, 跳出循环. 这里左移1位是为了让脚本剩余部分可以解析命令行剩余的参数, 这里只剩下了'now'参数.

## 4. 总结
